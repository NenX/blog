
Compilers generate PIC references to global variables by exploiting the following
interesting fact: no matter where we load an object module (including shared object modules) in memory,
the data segment is always the same distance from the code segment. 
Thus, the distance between any instruction in the code segment
and any variable in the data segment is a run-time constant, independent of the
absolute memory locations of the code and data segments.


Compilers that want to generate PIC references to global variables exploit
this fact by creating a table called the global offset table (GOT) at the beginning
of the data segment. The GOT contains an 8-byte entry for each global data
object (procedure or global variable) that is referenced by the object module.
The compiler also generates a relocation record for each entry in the GOT. At
load time, the dynamic linker relocates each GOT entry so that it contains the
absolute address of the object. Each object module that references global objects
has its own GOT.



Figure 7.18 shows the GOT from our example libvector.so shared module.
The addvec routine loads the address of the global variable addcnt indirectly via
GOT[3] and then increments addcnt in memory. The key idea here is that the offset
in the PC-relative reference to GOT[3] is a run-time constant.

Since addcnt is defined by the libvector.so module, the compiler could have
exploited the constant distance between the code and data segments by generating
a direct PC-relative reference to addcnt and adding a relocation for the linker
to resolve when it builds the shared module. However, if addcnt were defined
by another shared module, then the indirect access through the GOT would be
necessary. In this case, the compiler has chosen to use the most general solution,
the GOT, for all references.
--------------
Suppose that a program calls a function that is defined by a shared library. The
compiler has no way of predicting the run-time address of the function, since
the shared module that defines it could be loaded anywhere at run time. The
normal approach would be to generate a relocation record for the reference, which
the dynamic linker could then resolve when the program was loaded. However,
this approach would not be PIC, since it would require the linker to modify the
code segment of the calling module. GNU compilation systems solve this problem
using an interesting technique, called lazy binding, that defers the binding of each
procedure address until the first time the procedure is called.


The motivation for lazy binding is that a typical application program will
call only a handful of the hundreds or thousands of functions exported by a
shared library such as libc.so. By deferring the resolution of a functionâ€™s address
until it is actually called, the dynamic linker can avoid hundreds or thousands
of unnecessary relocations at load time. There is a nontrivial run-time overhead
the first time the function is called, but each call thereafter costs only a single
instruction and a memory reference for the indirection.

Lazy binding is implemented with a compact yet somewhat complex interaction between two data structures: the GOT and the procedure linkage table (PLT).
If an object module calls any functions that are defined in shared libraries, then it
has its own GOT and PLT. The GOT is part of the data segment. The PLT is part
of the code segment.


----------

Procedure linkage table (PLT). The PLT is an array of 16-byte code entries.
PLT[0] is a special entry that jumps into the dynamic linker. Each shared
library function called by the executable has its own PLT entry. Each of

these entries is responsible for invoking a specific function. PLT[1] (not
shown here) invokes the system startup function (__libc_start_main),
which initializes the execution environment, calls the main function, and
handles its return value. Entries starting at PLT[2] invoke functions called
by the user code. In our example, PLT[2] invokes addvec and PLT[3] (not
shown) invokes printf.


-----------------------
Global offset table (GOT). As we have seen, the GOT is an array of 8-byte
address entries. When used in conjunction with the PLT, GOT[0] and
GOT[1] contain information that the dynamic linker uses when it resolves
function addresses. GOT[2] is the entry point for the dynamic linker in
the ld-linux.so module. Each of the remaining entries corresponds to
a called function whose address needs to be resolved at run time. Each
has a matching PLT entry. For example, GOT[4] and PLT[2] correspond
to addvec. Initially, each GOT entry points to the second instruction in
the corresponding PLT entry









Step 1. Instead of directly calling addvec, the program calls into PLT[2], which
is the PLT entry for addvec.
Step 2. The first PLT instruction does an indirect jump through GOT[4]. Since
each GOT entry initially points to the second instruction in its corresponding PLT entry, the indirect jump simply transfers control back to the next
instruction in PLT[2].
Step 3. After pushing an ID for addvec (0x1) onto the stack, PLT[2] jumps to
PLT[0].
Step 4. PLT[0] pushes an argument for the dynamic linker indirectly through
GOT[1] and then jumps into the dynamic linker indirectly through GOT[2].
The dynamic linker uses the two stack entries to determine the runtime location of addvec, overwrites GOT[4] with this address, and passes
control to addvec.