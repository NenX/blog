<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>无味咸鱼</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="Python linux c++ nodejs git 前端">
    <link rel="preload" href="/blog/assets/css/0.styles.5be86d74.css" as="style"><link rel="preload" href="/blog/assets/js/app.d632149a.js" as="script"><link rel="preload" href="/blog/assets/js/2.57d6b41d.js" as="script"><link rel="preload" href="/blog/assets/js/46.75789747.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.c14a962d.js"><link rel="prefetch" href="/blog/assets/js/100.1cd56744.js"><link rel="prefetch" href="/blog/assets/js/101.a9aa44e2.js"><link rel="prefetch" href="/blog/assets/js/102.c645984d.js"><link rel="prefetch" href="/blog/assets/js/103.9ffb7658.js"><link rel="prefetch" href="/blog/assets/js/104.f7fd3dd0.js"><link rel="prefetch" href="/blog/assets/js/105.75006034.js"><link rel="prefetch" href="/blog/assets/js/106.63423224.js"><link rel="prefetch" href="/blog/assets/js/107.8c14363a.js"><link rel="prefetch" href="/blog/assets/js/108.2ddbcb02.js"><link rel="prefetch" href="/blog/assets/js/11.3d548b61.js"><link rel="prefetch" href="/blog/assets/js/12.9d2c4f8a.js"><link rel="prefetch" href="/blog/assets/js/13.a9b409d7.js"><link rel="prefetch" href="/blog/assets/js/14.3a02f7ba.js"><link rel="prefetch" href="/blog/assets/js/15.6a994d14.js"><link rel="prefetch" href="/blog/assets/js/16.9233eade.js"><link rel="prefetch" href="/blog/assets/js/17.4cfc67cf.js"><link rel="prefetch" href="/blog/assets/js/18.dfbd3923.js"><link rel="prefetch" href="/blog/assets/js/19.0412ef20.js"><link rel="prefetch" href="/blog/assets/js/20.2df1e597.js"><link rel="prefetch" href="/blog/assets/js/21.d97aa624.js"><link rel="prefetch" href="/blog/assets/js/22.0a983704.js"><link rel="prefetch" href="/blog/assets/js/23.6003bdaa.js"><link rel="prefetch" href="/blog/assets/js/24.a46fad1d.js"><link rel="prefetch" href="/blog/assets/js/25.5922eb09.js"><link rel="prefetch" href="/blog/assets/js/26.0644938c.js"><link rel="prefetch" href="/blog/assets/js/27.06d33185.js"><link rel="prefetch" href="/blog/assets/js/28.f2220207.js"><link rel="prefetch" href="/blog/assets/js/29.58089910.js"><link rel="prefetch" href="/blog/assets/js/3.a81e591c.js"><link rel="prefetch" href="/blog/assets/js/30.b206a41d.js"><link rel="prefetch" href="/blog/assets/js/31.55f76152.js"><link rel="prefetch" href="/blog/assets/js/32.ab6a81d4.js"><link rel="prefetch" href="/blog/assets/js/33.47cd718e.js"><link rel="prefetch" href="/blog/assets/js/34.d358307a.js"><link rel="prefetch" href="/blog/assets/js/35.2e063ad0.js"><link rel="prefetch" href="/blog/assets/js/36.a1b0c8d4.js"><link rel="prefetch" href="/blog/assets/js/37.295ab3a3.js"><link rel="prefetch" href="/blog/assets/js/38.523bd102.js"><link rel="prefetch" href="/blog/assets/js/39.4accf413.js"><link rel="prefetch" href="/blog/assets/js/4.3086808d.js"><link rel="prefetch" href="/blog/assets/js/40.8fc1ef90.js"><link rel="prefetch" href="/blog/assets/js/41.f4ab864c.js"><link rel="prefetch" href="/blog/assets/js/42.f7badf16.js"><link rel="prefetch" href="/blog/assets/js/43.c7431b80.js"><link rel="prefetch" href="/blog/assets/js/44.9f3dfe4f.js"><link rel="prefetch" href="/blog/assets/js/45.bd001a18.js"><link rel="prefetch" href="/blog/assets/js/47.b2ded0c6.js"><link rel="prefetch" href="/blog/assets/js/48.b0e921d0.js"><link rel="prefetch" href="/blog/assets/js/49.2a5955e8.js"><link rel="prefetch" href="/blog/assets/js/5.69539770.js"><link rel="prefetch" href="/blog/assets/js/50.6c29e98b.js"><link rel="prefetch" href="/blog/assets/js/51.88dff119.js"><link rel="prefetch" href="/blog/assets/js/52.0afcc8e5.js"><link rel="prefetch" href="/blog/assets/js/53.134a6419.js"><link rel="prefetch" href="/blog/assets/js/54.b8563d36.js"><link rel="prefetch" href="/blog/assets/js/55.8afa0dc5.js"><link rel="prefetch" href="/blog/assets/js/56.2b5ca77d.js"><link rel="prefetch" href="/blog/assets/js/57.225bf43f.js"><link rel="prefetch" href="/blog/assets/js/58.f834f952.js"><link rel="prefetch" href="/blog/assets/js/59.e3059bac.js"><link rel="prefetch" href="/blog/assets/js/6.45168e70.js"><link rel="prefetch" href="/blog/assets/js/60.1658c77b.js"><link rel="prefetch" href="/blog/assets/js/61.b432c203.js"><link rel="prefetch" href="/blog/assets/js/62.11e44c8e.js"><link rel="prefetch" href="/blog/assets/js/63.8d1878b1.js"><link rel="prefetch" href="/blog/assets/js/64.2cdd2ad3.js"><link rel="prefetch" href="/blog/assets/js/65.a4bfabc0.js"><link rel="prefetch" href="/blog/assets/js/66.b3184942.js"><link rel="prefetch" href="/blog/assets/js/67.74ad9981.js"><link rel="prefetch" href="/blog/assets/js/68.590fe076.js"><link rel="prefetch" href="/blog/assets/js/69.fca7907f.js"><link rel="prefetch" href="/blog/assets/js/7.f15ecd2a.js"><link rel="prefetch" href="/blog/assets/js/70.a3418552.js"><link rel="prefetch" href="/blog/assets/js/71.e7a530d9.js"><link rel="prefetch" href="/blog/assets/js/72.dc5c9206.js"><link rel="prefetch" href="/blog/assets/js/73.09f5d29e.js"><link rel="prefetch" href="/blog/assets/js/74.639591a1.js"><link rel="prefetch" href="/blog/assets/js/75.a0901b16.js"><link rel="prefetch" href="/blog/assets/js/76.2a01b2d3.js"><link rel="prefetch" href="/blog/assets/js/77.7ec2a4f4.js"><link rel="prefetch" href="/blog/assets/js/78.e6ef17fa.js"><link rel="prefetch" href="/blog/assets/js/79.536f3986.js"><link rel="prefetch" href="/blog/assets/js/8.489fa7fe.js"><link rel="prefetch" href="/blog/assets/js/80.73ac36a2.js"><link rel="prefetch" href="/blog/assets/js/81.561dad7f.js"><link rel="prefetch" href="/blog/assets/js/82.90684c17.js"><link rel="prefetch" href="/blog/assets/js/83.348ac9ff.js"><link rel="prefetch" href="/blog/assets/js/84.e69458a5.js"><link rel="prefetch" href="/blog/assets/js/85.07c5ba72.js"><link rel="prefetch" href="/blog/assets/js/86.716ad12a.js"><link rel="prefetch" href="/blog/assets/js/87.2edaa508.js"><link rel="prefetch" href="/blog/assets/js/88.00b2592e.js"><link rel="prefetch" href="/blog/assets/js/89.e1dcd8bc.js"><link rel="prefetch" href="/blog/assets/js/9.9e1f96c4.js"><link rel="prefetch" href="/blog/assets/js/90.37680ca0.js"><link rel="prefetch" href="/blog/assets/js/91.542b2403.js"><link rel="prefetch" href="/blog/assets/js/92.c22dfd64.js"><link rel="prefetch" href="/blog/assets/js/93.39be434e.js"><link rel="prefetch" href="/blog/assets/js/94.e855dfe7.js"><link rel="prefetch" href="/blog/assets/js/95.c49772f0.js"><link rel="prefetch" href="/blog/assets/js/96.b52f2418.js"><link rel="prefetch" href="/blog/assets/js/97.350150a7.js"><link rel="prefetch" href="/blog/assets/js/98.8416a182.js"><link rel="prefetch" href="/blog/assets/js/99.5947b522.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5be86d74.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">无味咸鱼</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/dictation/" class="nav-link">
  dictation
</a></div><div class="nav-item"><a href="/blog/fe/" class="nav-link">
  fe
</a></div><div class="nav-item"><a href="/blog/learning/" class="nav-link router-link-active">
  learning
</a></div><div class="nav-item"><a href="/blog/netWork/" class="nav-link">
  netWork
</a></div><div class="nav-item"><a href="/blog/基础/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/blog/工具/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/dictation/" class="nav-link">
  dictation
</a></div><div class="nav-item"><a href="/blog/fe/" class="nav-link">
  fe
</a></div><div class="nav-item"><a href="/blog/learning/" class="nav-link router-link-active">
  learning
</a></div><div class="nav-item"><a href="/blog/netWork/" class="nav-link">
  netWork
</a></div><div class="nav-item"><a href="/blog/基础/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/blog/工具/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>assembly</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>c</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>c++ 基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/learning/c++ 基础/2.变量和基础类型.html" class="sidebar-link">2.变量和基础类型</a></li><li><a href="/blog/learning/c++ 基础/3.字符串、向量和数组.html" class="active sidebar-link">3.字符串、向量和数组</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/learning/c++ 基础/3.字符串、向量和数组.html#命名空间的-using-声明" class="sidebar-link">命名空间的 using 声明</a></li><li class="sidebar-sub-header"><a href="/blog/learning/c++ 基础/3.字符串、向量和数组.html#标准库类型-string" class="sidebar-link">标准库类型 string</a></li><li class="sidebar-sub-header"><a href="/blog/learning/c++ 基础/3.字符串、向量和数组.html#标准库类型-vector" class="sidebar-link">标准库类型 vector</a></li><li class="sidebar-sub-header"><a href="/blog/learning/c++ 基础/3.字符串、向量和数组.html#迭代器介绍" class="sidebar-link">迭代器介绍</a></li><li class="sidebar-sub-header"><a href="/blog/learning/c++ 基础/3.字符串、向量和数组.html#_3-5数组" class="sidebar-link">3.5数组</a></li><li class="sidebar-sub-header"><a href="/blog/learning/c++ 基础/3.字符串、向量和数组.html#_3-6多维数组" class="sidebar-link">3.6多维数组</a></li></ul></li><li><a href="/blog/learning/c++ 基础/4.表达式.html" class="sidebar-link">4.表达式</a></li><li><a href="/blog/learning/c++ 基础/其他.html" class="sidebar-link">其他</a></li><li><a href="/blog/learning/c++ 基础/函数.html" class="sidebar-link">函数</a></li><li><a href="/blog/learning/c++ 基础/类.html" class="sidebar-link">类</a></li><li><a href="/blog/learning/c++ 基础/语句.html" class="sidebar-link">语句</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>cmake</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>cpp</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>gcc</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>README.md</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Windows 编程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>构建</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>本章将介绍两种重要的标准库类型 <code>string</code> 和 <code>vector</code>：</p> <ul><li>string：表示可变长的字符序列</li> <li>vector：存放某种给定类型对象的可变长序列</li> <li>数组：数组的实现与硬件密切相关，string 和 vector 都是对它的某种抽象，但其灵活性稍有不足</li> <li>迭代器：是 string 和 vector 的配套类型，常被用于访问 string 中的字符或 vector 中的元素</li></ul> <h2 id="命名空间的-using-声明"><a href="#命名空间的-using-声明" class="header-anchor">#</a> 命名空间的 using 声明</h2> <p>作用域操作符（::）的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
std<span class="token operator">::</span>string a<span class="token punctuation">;</span> <span class="token comment">// 使用命名空间 std 的中名字 string</span>
</code></pre></div><h3 id="using-声明（using-declaration）"><a href="#using-声明（using-declaration）" class="header-anchor">#</a> using 声明（using declaration）</h3> <ul><li>形式：<code>using namespace::name</code></li> <li>无须专门的前缀（namespace::name）也能使用所需的名字</li> <li>每个名字都需要独立的 using 声明：<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token comment">// 一行可以放多条 using 声明语句，但每个名字都必须有自己的 using 声明语句，以分号结束</span>
<span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span> <span class="token keyword">using</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> 
<span class="token keyword">using</span> std<span class="token operator">::</span>string<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string a <span class="token operator">=</span> <span class="token string">&quot;str&quot;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="头文件不应包含-using-声明语句"><a href="#头文件不应包含-using-声明语句" class="header-anchor">#</a> 头文件不应包含 using 声明语句</h3> <p>头文件的内容会被拷贝到所有包含它的文件中去，如果头文件里有某个 using 声明，那么每个使用该头文件的文件都会有这个声明。由于不经意间包含了一些名字，反而可以产生始料未及的名字冲突。</p> <h2 id="标准库类型-string"><a href="#标准库类型-string" class="header-anchor">#</a> 标准库类型 string</h2> <p>使用 <code>string</code> 类型必须包含 string 头文件，作为标准库的一部分，string 定义在命名空间 std 中：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> std<span class="token operator">::</span>string<span class="token punctuation">;</span>
</code></pre></div><h3 id="定义和初始化"><a href="#定义和初始化" class="header-anchor">#</a> 定义和初始化</h3> <table><thead><tr><th>初始化方式</th> <th style="text-align:left;">含义</th></tr></thead> <tbody><tr><td>string s1</td> <td style="text-align:left;">默认初始化，s1是一个空字符串</td></tr> <tr><td>string s2(s1)</td> <td style="text-align:left;">s2是s1的副本</td></tr> <tr><td>string s2 = s1</td> <td style="text-align:left;">等价于 s2(s1)</td></tr> <tr><td>string s3(&quot;value)</td> <td style="text-align:left;">s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符串外</td></tr> <tr><td>string s3 = &quot;value&quot;</td> <td style="text-align:left;">等价于s3(&quot;value&quot;)</td></tr> <tr><td>string s4(n,'c')</td> <td style="text-align:left;">把s4初始化为由连续n个字符'c'组成的串</td></tr></tbody></table> <p>直接初始化和拷贝初始化：</p> <ul><li>拷贝初始化（copy initialization）：使用等号（=）初始化一个变量</li> <li>直接初始化（direct initialization）：不使用等号初始化</li></ul> <h3 id="string-对象上的操作"><a href="#string-对象上的操作" class="header-anchor">#</a> string 对象上的操作</h3> <table><thead><tr><th>操作</th> <th style="text-align:left;">含义</th></tr></thead> <tbody><tr><td><code>os &lt;&lt; s</code></td> <td style="text-align:left;">将s写到输出流os当中，返回os</td></tr> <tr><td><code>is &gt;&gt; s</code></td> <td style="text-align:left;">从输入流is读取字符赋给s，返回is</td></tr> <tr><td><code>getline(is, s)</code></td> <td style="text-align:left;">从输入流is读取一行赋给s，返回is</td></tr> <tr><td><code>s.empty()</code></td> <td style="text-align:left;">s为空返回true，否则返回false</td></tr> <tr><td><code>s.size()</code></td> <td style="text-align:left;">返回s中字符的个数</td></tr> <tr><td><code>s[n]</code></td> <td style="text-align:left;">返回s中第n个字符的引用</td></tr> <tr><td><code>s1 + s2</code></td> <td style="text-align:left;">返回s1和s2连接后的结果</td></tr> <tr><td><code>s1 = s2</code></td> <td style="text-align:left;">用s2的副本替代s1原来的字符</td></tr> <tr><td><code>s1 == s2</code></td> <td style="text-align:left;">判断s1和s2所含的字符是否完全一样</td></tr> <tr><td><code>s1 != s2</code></td> <td style="text-align:left;">对大小写敏感</td></tr> <tr><td><code>&lt;, &lt;=, &gt;, &gt;=</code></td> <td style="text-align:left;">利用字符在字典中的顺序进行比较，大小写敏感</td></tr></tbody></table> <p>读写 string 对象</p> <ul><li><p>执行读写操作时，<code>string</code> 对象会自动忽略开头的空白并从第一个真的的字符开始读起，知道遇见下一处空白：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string s<span class="token punctuation">;</span>
cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
</code></pre></div><p>如果程序输入是“    HELLO WORLD    ”，则输出将是“HELLO”，输出结果没有包含任何空格。</p> <p>和内置类型的输入输出一样，string 对象的此类操作也是返回操作符左侧的运算对象作为其结果：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>
cin <span class="token operator">&gt;&gt;</span> s1 <span class="token operator">&gt;&gt;</span> s2<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> s2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
</code></pre></div><p>如果程序输入是“    HELLO WORLD    ”，则输出将是“HELLOWORLD”。</p></li> <li><p>读取未知数量的 string 对象：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string s<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> tmp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    s <span class="token operator">+=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>如果希望在最终的字符串中保留输入时的空格符，这时应使用 <code>getline</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string s<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    s <span class="token operator">+=</span> tmp<span class="token punctuation">;</span>
    s <span class="token operator">+=</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
</code></pre></div><p><code>getline</code> 函数接收一个输入流和一个 <code>string</code> 对象，函数从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来），然后把读取的内容存入 <code>string</code> 对象中（注意不存换行符）。</p></li></ul> <p>string 的 empty 和 size 操作：</p> <ul><li>empty：<code>string</code> 的一个成员函数，根据 <code>string</code> 对象是否为空返回一个对应的布尔值。</li> <li>size：返回 string 对象的长度</li> <li>string::size_type：<code>string</code> 类及其他大多数标准库类型定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性，<code>string::size_type</code> 即是其中的一种。<code>string::size_type</code> 是一个无符号类型的值而且足够存放下任何 <code>string</code> 对象的大小。所有用于存放 <code>string</code> 类的 <code>size</code> 函数返回值的变量，都应该是 <code>string::size_type</code> 类型的。<div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。如果一条表达式中已经有了 <code>size</code> 函数，就不要再使用 <code>int</code>，这样可以避免混用 <code>int</code> 和 <code>unsigned</code> 可能带来的问题。</p></div></li></ul> <p>比较 string 对象</p> <ul><li>相等性运算符（== 和 !=）：比较两个 <code>string</code> 对象是否长度相等且所包含的字符也全部相同。</li> <li>&lt;、&lt;=、&gt;、&gt;=：
<ul><li>如果两个 <code>string</code> 对象的长度不通，而且较短 <code>string</code> 对象的每个字符都与较长 <code>string</code> 对象对应位置上的字符相同，就说较短 <code>string</code> 对象小于较长 <code>string</code> 对象。</li> <li>如果 string 对象在某些对应位置上不一致，则 string 对象比较的结果其实就是 string 对象中第一对相异字符比较的结果。
字面值和 string 对象相加</li></ul></li></ul> <p>标准库允许将字符字面值与字符串字面值转化成 string 对象，所以在需要 string 对象的地方就可以使用这两种字面量来代替。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string s<span class="token punctuation">;</span>
s<span class="token operator">+=</span><span class="token string">'a'</span><span class="token punctuation">;</span>
s<span class="token operator">+=</span><span class="token string">'b'</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>当把 string 对象和字符字面量及字符串字面量混在一条语句中使用时，必须确保加法运算符（+）的两侧运算对象至少有一个是 string 对象。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string s <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
string s1 <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token string">&quot;hello&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
string s2 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;world&quot;</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span>
</code></pre></div><p>切记：c++ 语言中的字符串字面量并不是标准库类型 string 的对象，字符串字面量与 string 对象是不同的类型。</p></div> <h3 id="处理-string-对象中的字符"><a href="#处理-string-对象中的字符" class="header-anchor">#</a> 处理 string 对象中的字符</h3> <p>cctype 头文件中的函数</p> <table><thead><tr><th style="text-align:center;">函数</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">isalnum</td> <td style="text-align:center;">数字或字母</td></tr> <tr><td style="text-align:center;">isalpha</td> <td style="text-align:center;">数字</td></tr> <tr><td style="text-align:center;">isdigit</td> <td style="text-align:center;">字母</td></tr> <tr><td style="text-align:center;">isxdigit</td> <td style="text-align:center;">十六进制数字</td></tr> <tr><td style="text-align:center;">isprint</td> <td style="text-align:center;">可打印：空格、可使形式</td></tr> <tr><td style="text-align:center;">isspace</td> <td style="text-align:center;">空格、空白字符</td></tr> <tr><td style="text-align:center;">isgraph</td> <td style="text-align:center;">非空白可打印</td></tr> <tr><td style="text-align:center;">iscntrl</td> <td style="text-align:center;">控制字符</td></tr> <tr><td style="text-align:center;">ispunct</td> <td style="text-align:center;">标点符号</td></tr> <tr><td style="text-align:center;">islower</td> <td style="text-align:center;">小写字母</td></tr> <tr><td style="text-align:center;">isupper</td> <td style="text-align:center;">大写字母</td></tr> <tr><td style="text-align:center;">tolower</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">toupper</td> <td style="text-align:center;"></td></tr></tbody></table> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 <code>name.h</code>，C++ 则将这些文件命名为 <code>cname</code>。
<code>cctype</code> 头文件和 <code>ctype.h</code> 头文件的内容是一样的，只不过从命名规范上更复合 C++ 语言的要求。在 <code>cname</code> 头文件定义的名字从属于命名空间 <code>std</code>，而定义在 <code>name.h</code> 中的则不然。</p></div> <p>处理每个字符？使用基于范围的 for 语句</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用基于范围的 for 语句改变字符串中的字符</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;abcd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i <span class="token operator">:</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    i <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="标准库类型-vector"><a href="#标准库类型-vector" class="header-anchor">#</a> 标准库类型 vector</h2> <p><code>vector</code> 也称为容器（container），表示对象的集合。要想是用 vector，必须包含适当的头文件：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> std<span class="token operator">::</span>vector<span class="token punctuation">;</span>
</code></pre></div><p>C++ 既有类模板（class template）也有函数模板，其中 vector 是一个类模板。模板不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。</p> <p>编译器根据模板创建类或函数的过程称为实例化（instantiation），当使用模板时，需要指出编译器应把类或函数实例化为何种类型。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> i<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> vs<span class="token punctuation">;</span>
</code></pre></div><p><code>vector</code> 能容纳绝大多数类型的对象最为其元素，但是因为引用不是对象，所以不存在包含引用的 <code>vector</code>。</p> <p>在早期 C++ 标准中，如果 <code>vector</code> 的元素还是 <code>vector</code>，则其定义的形式与现在的 C++11 新标准略有不同。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> v1<span class="token punctuation">;</span> <span class="token comment">// 在外层 vector 对象的右尖括号和其元素之间添加一个空格，某些编译器仍需要</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> v2<span class="token punctuation">;</span> <span class="token comment">// 新标准定义形式</span>
</code></pre></div><h3 id="定义和初始化-vector-对象"><a href="#定义和初始化-vector-对象" class="header-anchor">#</a> 定义和初始化 vector 对象</h3> <table><thead><tr><th style="text-align:left;">初始化形式</th> <th style="text-align:left;">含义</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>vector&lt;T&gt; v1</code></td> <td style="text-align:left;">v1 是一个执行默认初始化的空 vector，其潜在的元素是 T 类型的</td></tr> <tr><td style="text-align:left;"><code>vector&lt;T&gt; v2(v1)</code></td> <td style="text-align:left;">v2 中包含了 v1 所有元素的副本</td></tr> <tr><td style="text-align:left;"><code>vector&lt;T&gt; v2 = v1</code></td> <td style="text-align:left;">等价于 <code>v2(v1)</code></td></tr> <tr><td style="text-align:left;"><code>vector&lt;T&gt; v3(n, val)</code></td> <td style="text-align:left;">v3 包含了 n 个重复的元素，每个元素的值都是 val</td></tr> <tr><td style="text-align:left;"><code>vector&lt;T&gt; v4(n)</code></td> <td style="text-align:left;">v4 包含了 n 个重复的执行了值初始化的对象</td></tr> <tr><td style="text-align:left;"><code>vector&lt;T&gt; v5{a, b, c...}</code></td> <td style="text-align:left;">v5 包含了初始值数量的元素，每个元素被赋予对应的初始值</td></tr> <tr><td style="text-align:left;"><code>vector&lt;T&gt; v5 = {a, b, c...}</code></td> <td style="text-align:left;">等价于 v5{a, b, c...}</td></tr></tbody></table> <ul><li><p>列表初始化 vector 对象</p> <p>C++ 语言提供了几种不同的<a href="/blog/learning/c++ 基础/变量和基础类型.html#_2-2-变量">初始化方式</a>，在大多数情况下这些初始化方式可以相互等价地使用。例外情况：</p> <ul><li>使用<a href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-string">拷贝初始化</a>时（即使用 = 时），只能提供一个初始值</li> <li>如果提供一个<a href="/blog/learning/c++ 基础/变量和基础类型.html#_2-6-1">类内初始值</a>，则只能使用拷贝初始化或者使用花括号的形式初始化。</li> <li>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里面进行列表初始化，而不能放在圆括号里。</li></ul></li> <li><p>值初始化：如果只提供 vector 对象容纳的元素数量而不提供初始值，此时库会创建一个值初始化的（value-initialized）的元素初值，并把它赋给容器的所有元素。这个初值由 vector 对象中的类型决定：</p> <ul><li>内置类型：比如 <code>int</code>，则元素初始值自动设为 0。</li> <li>类类型：比如 <code>string</code>，则元素由类默认初始化。</li></ul> <p>对于这种初始化的方式有两个特殊的限制：</p> <ul><li>如果 vector 对象中的元素不支持默认初始化，我们就必须提供初始的元素的值。</li> <li>如果只提供了元素的数量而没有设定初始值，只能使用直接初始化（而不是拷贝初始化）</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vi <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 必须使用直接初始化的形式指定向量大小</span>
</code></pre></div></li> <li><p>列表初始值还是元素数量？</p></li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10个值都是0的元素</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 1个值是10的元素</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10个值都是1的元素</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v4<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 2个值分别是10和1的元素</span>
</code></pre></div><ul><li>如果用的是圆括号，可以说提供的值是用来构造 <code>vector</code> 对象的。</li> <li>如果用的是花括号：
<ul><li>提供的值满足执行列表初始化时，将花括号的值当作元素初始值的列表来处理</li> <li>无法执行列表初始化时，将花括号的值用来构造 <code>vector</code> 对象</li></ul></li></ul> <h3 id="向-vector-对象添加元素"><a href="#向-vector-对象添加元素" class="header-anchor">#</a> 向 vector 对象添加元素</h3> <p>直接初始化的方式适应于：</p> <ol><li>初始值已知且数量少</li> <li>初始值是另一个 vector 对象的拷贝</li> <li>所有元素的初始值都一样
<code>push_back</code> 把一个值当成 <code>vector</code> 对象的尾元素压到（push）<code>vector</code> 对象的尾端（back）：</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
     v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>如果循环体内部包含向 <code>vector</code> 对象添加元素的语句，则不能使用范围 <code>for</code> 循环。</p> <p>范围 <code>for</code> 循环体内不应改变其所遍历序列的大小。</p></div> <h3 id="其他-vector-操作"><a href="#其他-vector-操作" class="header-anchor">#</a> 其他 vector 操作</h3> <table><thead><tr><th style="text-align:left;">vector 支持的操作</th> <th style="text-align:left;">含义</th></tr></thead> <tbody><tr><td style="text-align:left;">v.empty()</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">v.size()</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">v.push_back(t)</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">v[n]</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">v1 = v2</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">v1 = {a, b, c...}</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">v1 == v2</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">v1 != v2</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">&lt;=, &lt;, &gt;, &gt;=</td> <td style="text-align:left;"></td></tr></tbody></table> <h2 id="迭代器介绍"><a href="#迭代器介绍" class="header-anchor">#</a> 迭代器介绍</h2> <p>标准库容易都支持使用迭代器（iterator），但是其中只有少数几种同时支持下标运算符。</p> <p>严格来说，<code>string</code> 不属于容器类型，但是 <code>string</code> 支持很多与容器类型类似的操作：迭代器、下标运算符。</p> <ul><li>类似于指针类型，迭代器也提供了对对象的间接访问。</li> <li>迭代器的对象：容器中的元素或 string 对象中的字符</li> <li>使用迭代器可以访问某个元素，也能从一个元素移动到另一个元素</li> <li>迭代器有有效和无效之分
<ul><li>有效：指向某个元素或指向容器中尾元素的下一位置</li> <li>无效：其他都属于无效</li></ul></li></ul> <h3 id="使用迭代器"><a href="#使用迭代器" class="header-anchor">#</a> 使用迭代器</h3> <p>有迭代器的类型同时拥有返回迭代器的成员：</p> <blockquote><p><code>begin</code>：返回指向第一个元素的迭代器</p> <p><code>end</code>：返回指向容器尾元素的下一个位置（one past the end）的迭代器（尾迭代器 end iterator）</p></blockquote> <ul><li>迭代器的运算符</li></ul> <table><thead><tr><th style="text-align:left;">使用</th> <th style="text-align:left;">含义</th></tr></thead> <tbody><tr><td style="text-align:left;">*iter</td> <td style="text-align:left;">返回迭代器 iter 所指元素的引用</td></tr> <tr><td style="text-align:left;">iter-&gt;mem</td> <td style="text-align:left;">解引用 iter 并获取该元素名为 mem 的成员</td></tr> <tr><td style="text-align:left;">++iter</td> <td style="text-align:left;">令 iter 指向容器的下一个元素</td></tr> <tr><td style="text-align:left;">--iter</td> <td style="text-align:left;">令 iter 指向容器的上一个元素</td></tr> <tr><td style="text-align:left;">iter1 == iter2</td> <td style="text-align:left;">是否指向同一个元素</td></tr> <tr><td style="text-align:left;">iter1 != iter2</td> <td style="text-align:left;">是否指向同一个元素</td></tr></tbody></table> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 确保 s 非空</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> it <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>迭代器类型</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>string<span class="token operator">::</span>iterator it1<span class="token punctuation">;</span> <span class="token comment">// 读写</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator it2<span class="token punctuation">;</span> <span class="token comment">// 读写</span>

string<span class="token operator">::</span>const_iterator it3<span class="token punctuation">;</span> <span class="token comment">// 只读</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>const_iterator it4<span class="token punctuation">;</span> <span class="token comment">// 只读</span>


string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> string <span class="token function">cs</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> b1 <span class="token operator">=</span> cs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只读</span>
<span class="token keyword">auto</span> b2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读写</span>
<span class="token keyword">auto</span> b3 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C++11 新标准，只读</span>
</code></pre></div><blockquote><p>某些对 vector 的操作会使迭代器失效</p> <p>凡是使用了迭代器的循环体内，都不要向迭代器所属容器增减元素</p></blockquote> <h3 id="迭代器运算"><a href="#迭代器运算" class="header-anchor">#</a> 迭代器运算</h3> <p>vector 和 string 迭代器支持的运算</p> <table><thead><tr><th style="text-align:left;">使用</th> <th style="text-align:left;">含义</th></tr></thead> <tbody><tr><td style="text-align:left;">iter + n</td> <td style="text-align:left;">迭代器指向位置向前移动 n 个位置</td></tr> <tr><td style="text-align:left;">iter - n</td> <td style="text-align:left;">迭代器指向位置向后移动 n 个位置</td></tr> <tr><td style="text-align:left;">iter += n</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">iter -= n</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">iter1 - iter2</td> <td style="text-align:left;">迭代器相减的结果是它们之间的距离</td></tr> <tr><td style="text-align:left;">&gt;、&gt;=、&lt;=、&lt;</td> <td style="text-align:left;"></td></tr></tbody></table> <h2 id="_3-5数组"><a href="#_3-5数组" class="header-anchor">#</a> 3.5数组</h2> <p>存放类型相同对象的容器，大小确定不变，不能向数据增减元素。</p> <h3 id="_3-5-1定义和初始化数组"><a href="#_3-5-1定义和初始化数组" class="header-anchor">#</a> 3.5.1定义和初始化数组</h3> <blockquote><p>编译时数组的维度应该是已知的，即维度必须是一个大于零<a href="/blog/learning/c++ 基础/变量和基础类型.html#constexpr-和常量表达式">常量表达式</a>。</p> <p>定义数组时必须指定数组的类型，不允许用 auto 由初始值的列表推断类型</p></blockquote> <ul><li>显示初始化数组元素：
<ul><li>列表初始化数组元素，根据初始值计算推断出数组维度</li> <li>若指明维度：维度必须大于等于初始值元素的数量，剩下的元素被初始化为默认值</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 长度为2</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// {1, 2, 0}</span>
<span class="token keyword">int</span> a3<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span>
</code></pre></div></li> <li>字符数组特殊性：使用<a href="/blog/learning/c++ 基础/2. 变量和基础类型.html#_2-1-3-字面值常量">字符串字面值</a>对数组初始化，字符串末尾的空字符也会被拷贝到数组中去。</li> <li>不允许拷贝和赋值</li> <li>理解复杂的数组声明<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptrs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 包含10个整型指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>arrPtr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span> <span class="token comment">// 指向一个含有1个整型的数组</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arrRef<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token comment">// 引用一个含有1个整型的数组</span>
</code></pre></div></li></ul> <h3 id="_3-5-2访问数组元素"><a href="#_3-5-2访问数组元素" class="header-anchor">#</a> 3.5.2访问数组元素</h3> <p>使用数组下标时，通常将其定义为 <code>size_t</code> 类型。<code>size_t</code> 是一种机器相关的无符号整型，它被设计得足够大以便能表示内存中任意对象的大小。在 cstddef 头文件中定义了 size_t 类型，这个文件是C标准库 stddef 头文件的 C++ 版本。</p> <ul><li>遍历所有元素：范围 for 循环</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-5-3指针和数组"><a href="#_3-5-3指针和数组" class="header-anchor">#</a> 3.5.3指针和数组</h3> <blockquote><p>在很多使用到数组名字的地方，编译器会自动将其替换成一个指向该数组首元素的指针</p></blockquote> <p>作为 auto 变量的初始值时，推断出来的类型是指针。而使用 decltype 关键字时得到的类型还是数组：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">p</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p是一个指向arr首元素的整型指针</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> arr2<span class="token punctuation">;</span> <span class="token comment">// arr2 是一个包含一个元素的数组</span>
</code></pre></div><ul><li>指针也是迭代器
vector 和 string 的迭代器支持的运算，数组的指针全都支持。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> arr<span class="token punctuation">;</span>
<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 第二个元素设置为3</span>
<span class="token keyword">auto</span> ep <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 尾后指针</span>
</code></pre></div><ul><li>标准库函数begin和end
尽管可以计算出尾后指针，但是这种用法极易出错，使用 C++11 标准库的两个名为 begin 和 end 的函数更为安全。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">*</span>e <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> len <span class="token operator">=</span> e<span class="token operator">-</span>b<span class="token punctuation">;</span>
</code></pre></div><h3 id="_3-5-4-c风格字符串"><a href="#_3-5-4-c风格字符串" class="header-anchor">#</a> 3.5.4 C风格字符串</h3> <p>将字符串保存在字符数组中并以空字符结束（null terminated）。</p> <p>C 语言标准库提供了一组用于操作C风格字符串的函数，它们定义在 cstring 头文件中。</p> <table><thead><tr><th style="text-align:left;">用法</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:left;">strlen(p)</td> <td style="text-align:center;">返回p的长度，空字符串不计算在内</td></tr> <tr><td style="text-align:left;">strcmp(p1,p2)</td> <td style="text-align:center;">如果p1 == p2，返回0；如果p1 &gt; p2，返回一个正值；如果 p1 &lt; p2，返回一个负值</td></tr> <tr><td style="text-align:left;">strcat(p1,p2)</td> <td style="text-align:center;">将p2附加到p1，返回p1</td></tr> <tr><td style="text-align:left;">strcpy(p1,p2)</td> <td style="text-align:center;">将p2拷贝给p1，返回p1</td></tr></tbody></table> <p>传入此类函数的指针必须指向空字符串作为结束的字符数组。</p> <h3 id="_3-5-5-与旧代码的接口"><a href="#_3-5-5-与旧代码的接口" class="header-anchor">#</a> 3.5.5 与旧代码的接口</h3> <ul><li>混用 string 和 C 语言风格字符串
<ul><li>C 语言风格字符串 -&gt; string
<ul><li>允许使用字符串字面值/以空字符串结束的字符数组来初始化 string，或为string赋值</li> <li>在 string 对象的加法运算中允许使用C语言风格字符串作为其中一个运算对象</li></ul></li> <li>string -&gt; C语言风格字符串<div class="language-cpp extra-class"><pre class="language-cpp"><code>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">&quot;abcd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 错误</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li>使用数组初始化 vector 对象</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> cs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> vb <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ve <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> vb <span class="token operator">!=</span> ve<span class="token punctuation">;</span> <span class="token operator">++</span>vb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>vb <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>使用指针和数组很容易出错，现在的 C++ 程序应当尽量使用 vector 和迭代器，避免使用指针和内置数组</p></blockquote> <blockquote><p>应该尽量使用 string，避免使用 C 风格字符串</p></blockquote> <h2 id="_3-6多维数组"><a href="#_3-6多维数组" class="header-anchor">#</a> 3.6多维数组</h2> <ul><li>多维数组的初始化<div class="language-cpp extra-class"><pre class="language-cpp"><code>  <span class="token keyword">int</span> a1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// {{0,2},{3,4}}</span>
  <span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// {{1,0},{2,2}}</span>
</code></pre></div></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2/14/2020, 4:51:24 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/learning/c++ 基础/2.变量和基础类型.html" class="prev">
        2.变量和基础类型
      </a></span> <span class="next"><a href="/blog/learning/c++ 基础/4.表达式.html">
        4.表达式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.d632149a.js" defer></script><script src="/blog/assets/js/2.57d6b41d.js" defer></script><script src="/blog/assets/js/46.75789747.js" defer></script>
  </body>
</html>
