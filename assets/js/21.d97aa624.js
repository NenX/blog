(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{379:function(e,t,n){"use strict";n.r(t);var r=n(42),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"_1-3-it-pays-to-understand-how-compilation-systems-work"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-it-pays-to-understand-how-compilation-systems-work"}},[e._v("#")]),e._v(" 1.3 It Pays to Understand How Compilation Systems Work")]),e._v(" "),n("p",[e._v("For simple programs such as hello.c, we can rely on the compilation system to\nproduce correct and efficient machine code. However, there are some important\nreasons why programmers need to understand how compilation systems work:")]),e._v(" "),n("ul",[n("li",[e._v("Optimizing program performance. Modern compilers are sophisticated tools\nthat usually produce good code. As programmers, we do not need to know\nthe inner workings of the compiler in order to write efficient code. However,\nin order to make good coding decisions in our C programs, we do need a\nbasic understanding of machine-level code and how the compiler translates\ndifferent C statements into machine code. For example, is a switch statement\nalways more efficient than a sequence of if-else statements? How much\noverhead is incurred by a function call? Is a while loop more efficient than\na for loop? Are pointer references more efficient than array indexes? Why\ndoes our loop run so much faster if we sum into a local variable instead of an\nargument that is passed by reference? How can a function run faster when we\nsimply rearrange the parentheses in an arithmetic expression?")])]),e._v(" "),n("p",[e._v("In Chapter 3, we introduce x86-64, the machine language of recent generations of Linux, Macintosh, and Windows computers. We describe how\ncompilers translate different C constructs into this language. In Chapter 5,\nyou will learn how to tune the performance of your C programs by making\nsimple transformations to the C code that help the compiler do its job better.\nIn Chapter 6, you will learn about the hierarchical nature of the memory system, how C compilers store data arrays in memory, and how your C programs\ncan exploit this knowledge to run more efficiently.")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Understanding link-time errors.In our experience, some of the most perplexing programming errors are related to the operation of the linker, especially\nwhen you are trying to build large software systems. For example, what does\nit mean when the linker reports that it cannot resolve a reference? What is the\ndifference between a static variable and a global variable? What happens if\nyou define two global variables in different C files with the same name? What\nis the difference between a static library and a dynamic library? Why does it\nmatter what order we list libraries on the command line? And scariest of all,\nwhy do some linker-related errors not appear until run time? You will learn\nthe answers to these kinds of questions in Chapter 7.")])]),e._v(" "),n("li",[n("p",[e._v("Avoiding security holes. For many years, buffer overflow vulnerabilities have\naccounted for many of the security holes in network and Internet servers.\nThese vulnerabilities exist because too few programmers understand the need\nto carefully restrict the quantity and forms of data they accept from untrusted\nsources. A first step in learning secure programming is to understand the consequences of the way data and control information are stored on the program\nstack. We cover the stack discipline and buffer overflow vulnerabilities in\nChapter 3 as part of our study of assembly language. We will also learn about\nmethods that can be used by the programmer, compiler, and operating system\nto reduce the threat of attack.")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);