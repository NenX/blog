(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{427:function(l,e,s){"use strict";s.r(e);var t=s(42),h=Object(t.a)({},(function(){var l=this,e=l.$createElement,s=l._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[s("p",[l._v("SHLVL 是记录多个 Bash 进程实例嵌套深度的累加器，而 BASH_SUBSHELL 是记录一个 Bash 进程实例中多个子 Shell（subshell）嵌套深度的累加器。")]),l._v(" "),s("p",[l._v("从 c 语言层面讲，真正的子 Shell 是当前 Shell 进程调用了 fork() 函数，在内存中复制出一个几乎一模一样的子进程。而执行 bash 命令启动的所谓 child shell 是在执行 fork() 函数的基础上，又执行了一次 execve() 函数，execve() 函数会重新加载硬盘上的 bash 命令并执行，替换刚才 fork 出来的那个 shell 进程，除了传入的环境变量外，是个崭新的进程。")]),l._v(" "),s("p",[l._v("总结一下就是说，SHLVL 变量是记录了所谓的 child shell 的嵌套深度，而 BASH_SUBSHELL 是记录了 subshell 的嵌套深度。")]),l._v(" "),s("p",[l._v("把 child shell 叫成子 Shell，在口头上说说还可以，因为中文里没有其它什么好的叫法用来指代它，但你心里得明白，这不是术语子 Shell 真正的含义。")])])}),[],!1,null,null,null);e.default=h.exports}}]);