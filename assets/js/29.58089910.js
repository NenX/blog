(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{386:function(e,t,n){"use strict";n.r(t);var a=n(42),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_2-1-information-storage"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-information-storage"}},[e._v("#")]),e._v(" 2.1 Information Storage")]),e._v(" "),n("p",[e._v("Rather than accessing individual bits in memory, most computers use blocks of\n8 bits, or bytes, as the smallest addressable unit of memory. A machine-level\nprogram views memory as a very large array of bytes, referred to as "),n("strong",[e._v("virtual memory")]),e._v(".\nEvery byte of memory is identified by a unique number, known as its\naddress, and the set of all possible addresses is known as the "),n("strong",[e._v("virtual address space")]),e._v(".\nAs indicated by its name, this virtual address space is just a conceptual image\npresented to the machine-level program. The actual implementation (presented\nin Chapter 9) uses a combination of dynamic random access memory (DRAM),\nflash memory, disk storage, special hardware, and operating system software to\nprovide the program with what appears to be a monolithic byte array.")]),e._v(" "),n("p",[e._v("In subsequent chapters, we will cover how the compiler and run-time system\npartitions this memory space into more manageable units to store the different\nprogram objects, that is, program data, instructions, and control information.\nVarious mechanisms are used to allocate and manage the storage for different\nparts of the program. This management is all performed within the virtual address\nspace. For example, the value of a pointer in C—whether it points to an integer,\na structure, or some other program object—is the virtual address of the first byte\nof some block of storage. The C compiler also associates type information with\neach pointer, so that it can generate different machine-level code to access the\nvalue stored at the location designated by the pointer depending on the type of\nthat value. Although the C compiler maintains this type information, the actual\nmachine-level program it generates has no information about data types. It simply\ntreats each program object as a block of bytes and the program itself as a sequence\nof bytes.")]),e._v(" "),n("h2",{attrs:{id:"_2-1-1-hexadecimal-notation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-hexadecimal-notation"}},[e._v("#")]),e._v(" 2.1.1 Hexadecimal Notation")]),e._v(" "),n("p",[e._v("A single byte consists of 8 bits. In binary notation, its value ranges from 00000000"),n("sub",[e._v("2")]),e._v("\nto 11111111"),n("sub",[e._v("2")]),e._v(". When viewed as a decimal integer, its value ranges from 0"),n("sub",[e._v("10")]),e._v(" to 255"),n("sub",[e._v("10")]),e._v(".\nNeither notation is very convenient for describing bit patterns. Binary notation\nis too verbose, while with decimal notation it is tedious to convert to and from\nbit patterns. Instead, we write bit patterns as base-16, or "),n("strong",[e._v("hexadecimal")]),e._v(" numbers.\nHexadecimal (or simply “hex”) uses digits ‘0’ through ‘9’ along with characters\n‘A’ through ‘F’ to represent 16 possible values. Figure 2.2 shows the decimal and\nbinary values associated with the 16 hexadecimal digits. Written in hexadecimal,\nthe value of a single byte can range from 00"),n("sub",[e._v("16")]),e._v(" to FF"),n("sub",[e._v("16")]),e._v(".")]),e._v(" "),n("p",[e._v("In C, numeric constants starting with "),n("code",[e._v("0x")]),e._v(" or "),n("code",[e._v("0X")]),e._v(" are interpreted as being in\nhexadecimal. The characters ‘A’ through ‘F’ may be written in either upper- or\nlowercase. For example, we could write the number FA1D37B"),n("sub",[e._v("16")]),e._v(" as "),n("code",[e._v("0xFA1D37B")]),e._v(", as\n"),n("code",[e._v("0xfa1d37b")]),e._v(", or even mixing upper- and lowercase (e.g., "),n("code",[e._v("0xFa1D37b")]),e._v("). We will use\nthe C notation for representing hexadecimal values in this book.")]),e._v(" "),n("p",[e._v("A common task in working with machine-level programs is to manually convert between decimal, binary, and hexadecimal representations of bit patterns. Converting between binary and hexadecimal is straightforward, since it can be\nperformed one hexadecimal digit at a time. Digits can be converted by referring\nto a chart such as that shown in Figure 2.2. One simple trick for doing the conversion in your head is to memorize the decimal equivalents of hex digits A, C, and F.The hex values B, D, and E can be translated to decimal by computing their values\nrelative to the first three.")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th")])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("Hex digit")]),e._v(" "),n("td",[e._v("0")]),e._v(" "),n("td",[e._v("1")]),e._v(" "),n("td",[e._v("2")]),e._v(" "),n("td",[e._v("3")]),e._v(" "),n("td",[e._v("4")]),e._v(" "),n("td",[e._v("5")]),e._v(" "),n("td",[e._v("6")]),e._v(" "),n("td",[e._v("7")])]),e._v(" "),n("tr",[n("td",[e._v("Decimal value")]),e._v(" "),n("td",[e._v("0")]),e._v(" "),n("td",[e._v("1")]),e._v(" "),n("td",[e._v("2")]),e._v(" "),n("td",[e._v("3")]),e._v(" "),n("td",[e._v("4")]),e._v(" "),n("td",[e._v("5")]),e._v(" "),n("td",[e._v("6")]),e._v(" "),n("td",[e._v("7")])]),e._v(" "),n("tr",[n("td",[e._v("Binary value")]),e._v(" "),n("td",[e._v("0000")]),e._v(" "),n("td",[e._v("0001")]),e._v(" "),n("td",[e._v("0010")]),e._v(" "),n("td",[e._v("0011")]),e._v(" "),n("td",[e._v("0100")]),e._v(" "),n("td",[e._v("0101")]),e._v(" "),n("td",[e._v("0110")]),e._v(" "),n("td",[e._v("0111")])]),e._v(" "),n("tr",[n("td",[e._v("Hex digit")]),e._v(" "),n("td",[e._v("8")]),e._v(" "),n("td",[e._v("9")]),e._v(" "),n("td",[e._v("A")]),e._v(" "),n("td",[e._v("B")]),e._v(" "),n("td",[e._v("C")]),e._v(" "),n("td",[e._v("D")]),e._v(" "),n("td",[e._v("E")]),e._v(" "),n("td",[e._v("F")])]),e._v(" "),n("tr",[n("td",[e._v("Decimal value")]),e._v(" "),n("td",[e._v("8")]),e._v(" "),n("td",[e._v("9")]),e._v(" "),n("td",[e._v("10")]),e._v(" "),n("td",[e._v("11")]),e._v(" "),n("td",[e._v("12")]),e._v(" "),n("td",[e._v("13")]),e._v(" "),n("td",[e._v("14")]),e._v(" "),n("td",[e._v("15")])]),e._v(" "),n("tr",[n("td",[e._v("Binary value")]),e._v(" "),n("td",[e._v("1000")]),e._v(" "),n("td",[e._v("1001")]),e._v(" "),n("td",[e._v("1010")]),e._v(" "),n("td",[e._v("1011")]),e._v(" "),n("td",[e._v("1100")]),e._v(" "),n("td",[e._v("1101")]),e._v(" "),n("td",[e._v("1110")]),e._v(" "),n("td",[e._v("1111")])])])]),e._v(" "),n("p",[e._v("For example, suppose you are given the number 0x173A4C. You can convert\nthis to binary format by expanding each hexadecimal digit, as follows:")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th")])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("Hexadecimal")]),e._v(" "),n("td",[e._v("1")]),e._v(" "),n("td",[e._v("7")]),e._v(" "),n("td",[e._v("3")]),e._v(" "),n("td",[e._v("A")]),e._v(" "),n("td",[e._v("4")]),e._v(" "),n("td",[e._v("C")])]),e._v(" "),n("tr",[n("td",[e._v("Binary")]),e._v(" "),n("td",[e._v("0001")]),e._v(" "),n("td",[e._v("0111")]),e._v(" "),n("td",[e._v("0011")]),e._v(" "),n("td",[e._v("1010")]),e._v(" "),n("td",[e._v("0100")]),e._v(" "),n("td",[e._v("1100")])])])]),e._v(" "),n("p",[e._v("This gives the binary representation 000101110011101001001100.")]),e._v(" "),n("p",[e._v("Conversely, given a binary number 1111001010110110110011, you convert it\nto hexadecimal by first splitting it into groups of 4 bits each. Note, however, that if\nthe total number of bits is not a multiple of 4, you should make the leftmost group\nbe the one with fewer than 4 bits, effectively padding the number with leading\nzeros. Then you translate each group of bits into the corresponding hexadecimal\ndigit:")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th"),e._v(" "),n("th")])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("Binary")]),e._v(" "),n("td",[e._v("11")]),e._v(" "),n("td",[e._v("1100")]),e._v(" "),n("td",[e._v("1010")]),e._v(" "),n("td",[e._v("1101")]),e._v(" "),n("td",[e._v("1011")]),e._v(" "),n("td",[e._v("0011")])]),e._v(" "),n("tr",[n("td",[e._v("Hexadecimal")]),e._v(" "),n("td",[e._v("3")]),e._v(" "),n("td",[e._v("C")]),e._v(" "),n("td",[e._v("A")]),e._v(" "),n("td",[e._v("D")]),e._v(" "),n("td",[e._v("B")]),e._v(" "),n("td",[e._v("3")])])])]),e._v(" "),n("h2",{attrs:{id:"_2-1-2-data-sizes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-data-sizes"}},[e._v("#")]),e._v(" 2.1.2 Data Sizes")]),e._v(" "),n("p",[e._v("Every computer has a word size, indicating the nominal size of pointer data. Since\na virtual address is encoded by such a word, the most important system parameter\ndetermined by the word size is the maximum size of the virtual address space. That\nis, for a machine with a w-bit word size, the virtual addresses can range from 0 to\n2"),n("sup",[e._v("w")]),e._v(" − 1, giving the program access to at most 2"),n("sup",[e._v("w")]),e._v(" bytes.")]),e._v(" "),n("p",[e._v("In recent years, there has been a widespread shift from machines with 32-\nbit word sizes to those with word sizes of 64 bits. This occurred first for high-end\nmachines designed for large-scale scientific and database applications, followed\nby desktop and laptop machines, and most recently for the processors found in\nsmartphones. A 32-bit word size limits the virtual address space to 4 gigabytes\n(written 4 GB), that is, just over 4 × 10"),n("sup",[e._v("9")]),e._v(" bytes. Scaling up to a 64-bit word size\nleads to a virtual address space of 16 exabytes, or around 1.84 × 10"),n("sup",[e._v("19")]),e._v(" bytes.")]),e._v(" "),n("p",[e._v("Most 64-bit machines can also run programs compiled for use on 32-bit machines, a form of backward compatibility. So, for example, when a program prog.c\nis compiled with the directive")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[e._v("linux"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" gcc -m32 prog.c\n")])])]),n("p",[e._v("then this program will run correctly on either a 32-bit or a 64-bit machine. On the\nother hand, a program compiled with the directive")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[e._v("linux"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" gcc -m64 prog.c\n")])])]),n("p",[e._v("will only run on a 64-bit machine. We will therefore refer to programs as being\neither “32-bit programs” or “64-bit programs,” since the distinction lies in how a\nprogram is compiled, rather than the type of machine on which it runs.")]),e._v(" "),n("p",[e._v("Computers and compilers support multiple data formats using different ways\nto encode data, such as integers and floating point, as well as different lengths.\nFor example, many machines have instructions for manipulating single bytes, as\nwell as integers represented as 2-, 4-, and 8-byte quantities. They also support\nfloating-point numbers represented as 4- and 8-byte quantities.")]),e._v(" "),n("p",[e._v("The C language supports multiple data formats for both integer and floating-point data.\nFigure 2.3 shows the number of bytes typically allocated for different C\ndata types. (We discuss the relation between what is guaranteed by the C standard\nversus what is typical in Section 2.2.) The exact numbers of bytes for some data\ntypes depends on how the program is compiled. We show sizes for typical 32-bit\nand 64-bit programs. Integer data can be either signed, able to represent negative,\nzero, and positive values, or unsigned, only allowing nonnegative values. Data\ntype char represents a single byte. Although the name char derives from the fact\nthat it is used to store a single character in a text string, it can also be used to store\ninteger values. Data types short, int, and long are intended to provide a range of\nsizes. Even when compiled for 64-bit systems, data type int is usually just 4 bytes.\nData type long commonly has 4 bytes in 32-bit programs and 8 bytes in 64-bit\nprograms")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Signed")]),e._v(" "),n("th",[e._v("Unsigned")]),e._v(" "),n("th",[e._v("32-bit")]),e._v(" "),n("th",[e._v("64-bit")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("[signed] char")]),e._v(" "),n("td",[e._v("unsigned char")]),e._v(" "),n("td",[e._v("1")]),e._v(" "),n("td",[e._v("1")])]),e._v(" "),n("tr",[n("td",[e._v("short")]),e._v(" "),n("td",[e._v("unsigned short")]),e._v(" "),n("td",[e._v("2")]),e._v(" "),n("td",[e._v("2")])]),e._v(" "),n("tr",[n("td",[e._v("int")]),e._v(" "),n("td",[e._v("unsigned")]),e._v(" "),n("td",[e._v("4")]),e._v(" "),n("td",[e._v("4")])]),e._v(" "),n("tr",[n("td",[e._v("long")]),e._v(" "),n("td",[e._v("unsigned long")]),e._v(" "),n("td",[e._v("4")]),e._v(" "),n("td",[e._v("8")])]),e._v(" "),n("tr",[n("td",[e._v("int32_t")]),e._v(" "),n("td",[e._v("uint32_t")]),e._v(" "),n("td",[e._v("4")]),e._v(" "),n("td",[e._v("4")])]),e._v(" "),n("tr",[n("td",[e._v("int64_t")]),e._v(" "),n("td",[e._v("uint64_t")]),e._v(" "),n("td",[e._v("8")]),e._v(" "),n("td",[e._v("8")])]),e._v(" "),n("tr",[n("td",[e._v("char *")]),e._v(" "),n("td"),e._v(" "),n("td",[e._v("4")]),e._v(" "),n("td",[e._v("8")])]),e._v(" "),n("tr",[n("td",[e._v("float")]),e._v(" "),n("td"),e._v(" "),n("td",[e._v("4")]),e._v(" "),n("td",[e._v("4")])]),e._v(" "),n("tr",[n("td",[e._v("double")]),e._v(" "),n("td"),e._v(" "),n("td",[e._v("8")]),e._v(" "),n("td",[e._v("8")])])])]),e._v(" "),n("p",[e._v("To avoid the vagaries of relying on “typical” sizes and different compiler settings, ISO C99 introduced a class of data types where the data sizes are fixed\nregardless of compiler and machine settings. Among these are data types int32_t\nand int64_t, having exactly 4 and 8 bytes, respectively. Using fixed-size integer\ntypes is the best way for programmers to have close control over data representations.")]),e._v(" "),n("p",[e._v("Most of the data types encode signed values, unless prefixed by the keyword\nunsigned or using the specific unsigned declaration for fixed-size data types. The\nexception to this is data type char. Although most compilers and machines treat\nthese as signed data, the C standard does not guarantee this. Instead, as indicated\nby the square brackets, the programmer should use the declaration signed char\nto guarantee a 1-byte signed value. In many contexts, however, the program’s\nbehavior is insensitive to whether data type char is signed or unsigned.")]),e._v(" "),n("p",[e._v("The C language allows a variety of ways to order the keywords and to include\nor omit optional keywords. As examples, all of the following declarations have\nidentical meaning:")]),e._v(" "),n("div",{staticClass:"language-cpp extra-class"},[n("pre",{pre:!0,attrs:{class:"language-cpp"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v(" a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" b"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" c"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" d"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),n("p",[e._v("We will consistently use the forms found in Figure 2.3.")]),e._v(" "),n("p",[e._v("Figure 2.3 also shows that a pointer (e.g., a variable declared as being of\ntype char *) uses the full word size of the program. Most machines also support\ntwo different floating-point formats: single precision, declared in C as float,\nand double precision, declared in C as double. These formats use 4 and 8 bytes,\nrespectively.")]),e._v(" "),n("p",[e._v("Programmers should strive to make their programs portable across differentmachines and compilers.\nOne aspect of portability is to make the program insensitive to the exact sizes of the different data types.\nThe C standards set lower bounds on the numeric ranges of the different data types, as will be covered later, but there are no upper bounds (except with the fixed-size types). With 32-bit machines and 32-bit programs being the dominant combination from around 1980 until around 2010,\nmany programs have been written assuming the allocations listed for 32-bit programs in Figure 2.3. With the transition to 64-bit machines,\nmany hidden word size dependencies have arisen as bugs in migrating these programs to new\nmachines. For example, many programmers historically assumed that an object\ndeclared as type int could be used to store a pointer. This works fine for most\n32-bit programs, but it leads to problems for 64-bit programs.")]),e._v(" "),n("h2",{attrs:{id:"_2-1-3-addressing-and-byte-ordering"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-addressing-and-byte-ordering"}},[e._v("#")]),e._v(" 2.1.3 Addressing and Byte Ordering")]),e._v(" "),n("p",[e._v("For program objects that span multiple bytes, we must establish two conventions:\nwhat the address of the object will be, and how we will order the bytes in memory.\nIn virtually all machines, a multi-byte object is stored as a contiguous sequence\nof bytes, with the address of the object given by the smallest address of the bytes\nused. For example, suppose a variable x of type int has address 0x100; that is, the\nvalue of the address expression &x is 0x100. Then (assuming data type int has a\n32-bit representation) the 4 bytes of x would be stored in memory locations 0x100,\n0x101, 0x102, and 0x103.")]),e._v(" "),n("p",[e._v("For ordering the bytes representing an object, there are two common conventions. Consider a w-bit integer having a bit representation [x"),n("sub",[e._v("w−1")]),e._v(", x"),n("sub",[e._v("w−2")]),e._v(",...,x"),n("sub",[e._v("1")]),e._v(", x"),n("sub",[e._v("0")]),e._v("], where xw−1 is the most significant bit and x0 is the least. Assuming w is a multiple of 8, these bits can be grouped as bytes, with the most significant byte having bits [x"),n("sub",[e._v("w−1")]),e._v(", x"),n("sub",[e._v("w−2")]),e._v(",...,x"),n("sub",[e._v("w−8")]),e._v("], the least significant byte having bits [x"),n("sub",[e._v("7")]),e._v(", x"),n("sub",[e._v("6")]),e._v(",...,x"),n("sub",[e._v("0")]),e._v("], and\nthe other bytes having bits from the middle. Some machines choose to store the object in memory ordered from least significant byte to most, while other machines\nstore them from most to least. The former convention—where the least significant\nbyte comes first—is referred to as "),n("strong",[e._v("little endian")]),e._v(". The latter convention—where the\nmost significant byte comes first—is referred to as "),n("strong",[e._v("big endian")]),e._v(".")]),e._v(" "),n("p",[e._v("Suppose the variable x of type int and at address 0x100 has a hexadecimal\nvalue of 0x01234567. The ordering of the bytes within the address range 0x100\nthrough 0x103 depends on the type of machine:")]),e._v(" "),n("ul",[n("li",[e._v("Big endian\n| 0x100 | 0x101 | 0x102 | 0x103 |\n| ----- | ----- | ----- | ----- |\n| 01    | 23    | 45    | 67    |")]),e._v(" "),n("li",[e._v("Little endian\n| 0x100 | 0x101 | 0x102 | 0x103 |\n| ----- | ----- | ----- | ----- |\n| 67    | 45    | 23    | 01    |")])]),e._v(" "),n("p",[e._v("Note that in the word 0x01234567 the high-order byte has hexadecimal value\n0x01, while the low-order byte has value 0x67.")]),e._v(" "),n("p",[e._v("Most Intel-compatible machines operate exclusively in little-endian mode. On the other hand,\nmost machines from IBM and Oracle (arising from their acquisition of Sun Microsystems in 2010) operate in big-endian mode.\nNote that we said “most.” The conventions do not split precisely along corporate boundaries. For example,\nboth IBM and Oracle manufacture machines that use Intel-compatible processors and hence are little endian. Many recent microprocessor chips are\nbi-endian, meaning that they can be configured to operate as either little- or\nbig-endian machines. In practice, however, byte ordering becomes fixed once a\nparticular operating system is chosen. For example, ARM microprocessors, used\nin many cell phones, have hardware that can operate in either little- or big-endian\nmode, but the two most common operating systems for these chips—Android\n(from Google) and IOS (from Apple)—operate only in little-endian mode.")]),e._v(" "),n("p",[e._v("People get surprisingly emotional about which byte ordering is the proper one.\nIn fact, the terms “little endian” and “big endian” come from the book Gulliver’s\nTravels by Jonathan Swift, where two warring factions could not agree as to how a\nsoft-boiled egg should be opened—by the little end or by the big. Just like the egg\nissue, there is no technological reason to choose one byte ordering convention over\nthe other, and hence the arguments degenerate into bickering about sociopolitical\nissues. As long as one of the conventions is selected and adhered to consistently,\nthe choice is arbitrary.")]),e._v(" "),n("p",[e._v("For most application programmers, the byte orderings used by their machines\nare totally invisible; programs compiled for either class of machine give identical results. At times, however, byte ordering becomes an issue.\nThe first is when binary data are communicated over a network between different machines.\nA common problem is for data produced by a little-endian machine to be sent to\na big-endian machine, or vice versa, leading to the bytes within the words being\nin reverse order for the receiving program. To avoid such problems, code written\nfor networking applications must follow established conventions for byte ordering to make sure the sending machine converts its internal representation to the\nnetwork standard, while the receiving machine converts the network standard to\nits internal representation. We will see examples of these conversions in Chapter 11.")]),e._v(" "),n("p",[e._v("A second case where byte ordering becomes important is when looking at\nthe byte sequences representing integer data. This occurs often when inspecting\nmachine-level programs. As an example, the following line occurs in a file that\ngives a text representation of the machine-level code for an Intel x86-64 processor:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("4004d3: 01 05 43 0b 20 00 add %eax,0x200b43(%rip)\n")])])]),n("p",[e._v("This line was generated by a disassembler, a tool that determines the instruction\nsequence represented by an executable program file. We will learn more about\ndisassemblers and how to interpret lines such as this in Chapter 3. For now, we\nsimply note that this line states that the hexadecimal byte sequence 01 05 43 0b\n20 00 is the byte-level representation of an instruction that adds a word of data\nto the value stored at an address computed by adding 0x200b43 to the current\nvalue of the program counter, the address of the next instruction to be executed.\nIf we take the final 4 bytes of the sequence 43 0b 20 00 and write them in reverse\norder, we have 00 20 0b 43. Dropping the leading 0, we have the value 0x200b43,\nthe numeric value written on the right. Having bytes appear in reverse order\nis a common occurrence when reading machine-level program representations\ngenerated for little-endian machines such as this one. The natural way to write a\nbyte sequence is to have the lowest-numbered byte on the left and the highest on\nthe right, but this is contrary to the normal way of writing numbers with the most\nsignificant digit on the left and the least on the right.")]),e._v(" "),n("p",[e._v("A third case where byte ordering becomes visible is when programs are\nwritten that circumvent the normal type system. In the C language, this can be\ndone using a cast or a union to allow an object to be referenced according to\na different data type from which it was created. Such coding tricks are strongly\ndiscouraged for most application programming, but they can be quite useful and\neven necessary for system-level programming.")]),e._v(" "),n("p",[e._v("Figure 2.4 shows C code that uses casting to access and print the byte representations of different program objects. We use typedef to define data type\nbyte_pointer as a pointer to an object of type unsigned char. Such a byte pointer\nreferences a sequence of bytes where each byte is considered to be a nonnegative integer. The first routine show_bytes is given the address of a sequence of\nbytes, indicated by a byte pointer, and a byte count. The byte count is specified as\nhaving data type size_t, the preferred data type for expressing the sizes of data\nstructures. It prints the individual bytes in hexadecimal. The C formatting directive %.2x indicates that an integer should be printed in hexadecimal with at least\n2 digits.")]),e._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token macro property"}},[n("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("include")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("<stdio.h>")])]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typedef")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("byte_pointer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_bytes")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("byte_pointer start"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" size_t len"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("i "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" i "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" len"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" i"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('" %.2x"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" start"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_bytes")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("byte_pointer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&")]),e._v("x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("sizeof")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_float")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("float")]),e._v(" x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_bytes")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("byte_pointer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&")]),e._v("x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("sizeof")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("float")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_pointer")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_bytes")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("byte_pointer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&")]),e._v("x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("sizeof")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("p",[e._v("Procedures show_int, show_float, and show_pointer demonstrate how to\nuse procedure show_bytes to print the byte representations of C program objects\nof type int, float, and void *, respectively. Observe that they simply pass show_\nbytes a pointer &x to their argument x, casting the pointer to be of type unsigned\nchar *. This cast indicates to the compiler that the program should consider the\npointer to be to a sequence of bytes rather than to an object of the original data\ntype. This pointer will then be to the lowest byte address occupied by the object.")]),e._v(" "),n("p",[e._v("These procedures use the C sizeof operator to determine the number of bytes\nused by the object. In general, the expression sizeof(T ) returns the number of\nbytes required to store an object of type T . Using sizeof rather than a fixed value\nis one step toward writing code that is portable across different machine types.")]),e._v(" "),n("p",[e._v("We ran the code shown in Figure 2.5 on several different machines, giving the\nresults shown in Figure 2.6. The following machines were used:")]),e._v(" "),n("ul",[n("li",[e._v("Linux 32 Intel IA32 processor running Linux.")]),e._v(" "),n("li",[e._v("Windows Intel IA32 processor running Windows.")]),e._v(" "),n("li",[e._v("Sun Sun Microsystems SPARC processor running Solaris. (These machines are now produced by Oracle.)")]),e._v(" "),n("li",[e._v("Linux 64 Intel x86-64 processor running Linux.")])]),e._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("test_show_bytes")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" val"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" \n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" ival "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" val"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("float")]),e._v(" fval "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("float")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" ival"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("pval "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&")]),e._v("ival"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("ival"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_float")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("fval"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("show_pointer")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("pval"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("table",[n("thead",[n("tr",[n("th",[e._v("Machine")]),e._v(" "),n("th",[e._v("Value")]),e._v(" "),n("th",[e._v("Type")]),e._v(" "),n("th",[e._v("Bytes  (hex)")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("Linux 32")]),e._v(" "),n("td",[e._v("12,345")]),e._v(" "),n("td",[e._v("int")]),e._v(" "),n("td",[e._v("39 30 00 00")])]),e._v(" "),n("tr",[n("td",[e._v("Windows")]),e._v(" "),n("td",[e._v("12,345")]),e._v(" "),n("td",[e._v("int")]),e._v(" "),n("td",[e._v("39 30 00 00")])]),e._v(" "),n("tr",[n("td",[e._v("Sun")]),e._v(" "),n("td",[e._v("12,345")]),e._v(" "),n("td",[e._v("int")]),e._v(" "),n("td",[e._v("00 00 30 39")])]),e._v(" "),n("tr",[n("td",[e._v("Linux 64")]),e._v(" "),n("td",[e._v("12,345")]),e._v(" "),n("td",[e._v("int")]),e._v(" "),n("td",[e._v("39 30 00 00")])]),e._v(" "),n("tr",[n("td",[e._v("Linux 32")]),e._v(" "),n("td",[e._v("12,345.0")]),e._v(" "),n("td",[e._v("float")]),e._v(" "),n("td",[e._v("00 e4 40 46")])]),e._v(" "),n("tr",[n("td",[e._v("Windows")]),e._v(" "),n("td",[e._v("12,345.0")]),e._v(" "),n("td",[e._v("float")]),e._v(" "),n("td",[e._v("00 e4 40 46")])]),e._v(" "),n("tr",[n("td",[e._v("Sun")]),e._v(" "),n("td",[e._v("12,345.0")]),e._v(" "),n("td",[e._v("float")]),e._v(" "),n("td",[e._v("46 40 e4 00")])]),e._v(" "),n("tr",[n("td",[e._v("Linux 64")]),e._v(" "),n("td",[e._v("12,345.0")]),e._v(" "),n("td",[e._v("float")]),e._v(" "),n("td",[e._v("00 e4 40 46")])]),e._v(" "),n("tr",[n("td",[e._v("Linux 32")]),e._v(" "),n("td",[e._v("&ival")]),e._v(" "),n("td",[e._v("int *")]),e._v(" "),n("td",[e._v("e4 f9 ff bf")])]),e._v(" "),n("tr",[n("td",[e._v("Windows")]),e._v(" "),n("td",[e._v("&ival")]),e._v(" "),n("td",[e._v("int *")]),e._v(" "),n("td",[e._v("b4 cc 22 00")])]),e._v(" "),n("tr",[n("td",[e._v("Sun")]),e._v(" "),n("td",[e._v("&ival")]),e._v(" "),n("td",[e._v("int *")]),e._v(" "),n("td",[e._v("ef ff fa 0c")])]),e._v(" "),n("tr",[n("td",[e._v("Linux 64")]),e._v(" "),n("td",[e._v("&ival")]),e._v(" "),n("td",[e._v("int *")]),e._v(" "),n("td",[e._v("b8 11 e5 ff ff 7f 00 00")])])])]),e._v(" "),n("p",[e._v("Our argument 12,345 has hexadecimal representation 0x00003039. For the int\ndata, we get identical results for all machines, except for the byte ordering. In\nparticular, we can see that the least significant byte value of 0x39 is printed first\nfor Linux 32, Windows, and Linux 64, indicating little-endian machines, and last\nfor Sun, indicating a big-endian machine. Similarly, the bytes of the float data\nare identical, except for the byte ordering. On the other hand, the pointer values\nare completely different. The different machine/operating system configurations\nuse different conventions for storage allocation. One feature to note is that the\nLinux 32, Windows, and Sun machines use 4-byte addresses, while the Linux 64\nmachine uses 8-byte addresses.")]),e._v(" "),n("p",[e._v("Observe that although the floating-point and the integer data both encode\nthe numeric value 12,345, they have very different byte patterns: 0x00003039\nfor the integer and 0x4640E400 for floating point. In general, these two formats\nuse different encoding schemes. If we expand these hexadecimal patterns into\nbinary form and shift them appropriately, we find a sequence of 13 matching bits,\nindicated by a sequence of asterisks, as follows:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("   0   0   0   0   3   0   3   9\n00000000000000000011000000111001\n                   *************\n          01000110010000001110010000000000\n             4   6   4   0   E   4   0   0\n")])])]),n("p",[e._v("This is not coincidental. We will return to this example when we study floatingpoint formats.")]),e._v(" "),n("h2",{attrs:{id:"_2-1-4-representing-strings"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-representing-strings"}},[e._v("#")]),e._v(" 2.1.4 Representing Strings")]),e._v(" "),n("p",[e._v('A string in C is encoded by an array of characters terminated by the null (having\nvalue 0) character. Each character is represented by some standard encoding, with\nthe most common being the ASCII character code. Thus, if we run our routine\nshow_bytes with arguments "12345" and 6 (to include the terminating character),\nwe get the result 31 32 33 34 35 00. Observe that the ASCII code for decimal digit\nx happens to be 0x3x, and that the terminating byte has the hex representation\n0x00. This same result would be obtained on any system using ASCII as its\ncharacter code, independent of the byte ordering and word size conventions. As\na consequence, text data are more platform independent than binary data.')]),e._v(" "),n("h2",{attrs:{id:"_2-1-5-representing-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-representing-code"}},[e._v("#")]),e._v(" 2.1.5 Representing Code")]),e._v(" "),n("p",[e._v("Consider the following C function:")]),e._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("sum")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" y"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" x "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" y"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("p",[e._v("When compiled on our sample machines, we generate machine code having\nthe following byte representations:")]),e._v(" "),n("ul",[n("li",[e._v("Linux 32: 55 89 e5 8b 45 0c 03 45 08 c9 c3")]),e._v(" "),n("li",[e._v("Windows:55 89 e5 8b 45 0c 03 45 08 5d c3")]),e._v(" "),n("li",[e._v("Sun:81 c3 e0 08 90 02 00 09")]),e._v(" "),n("li",[e._v("Linux 64: 55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3")])]),e._v(" "),n("p",[e._v("Here we find that the instruction codings are different. Different machine types\nuse different and incompatible instructions and encodings. Even identical processors running different operating systems have differences in their coding conventions and hence are not binary compatible. Binary code is seldom portable across different combinations of machine and operating system.")]),e._v(" "),n("p",[e._v("A fundamental concept of computer systems is that a program, from the\nperspective of the machine, is simply a sequence of bytes. The machine has no\ninformation about the original source program, except perhaps some auxiliary\ntables maintained to aid in debugging. We will see this more clearly when we study\nmachine-level programming in Chapter 3.")]),e._v(" "),n("h2",{attrs:{id:"_2-1-6-introduction-to-boolean-algebra"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-6-introduction-to-boolean-algebra"}},[e._v("#")]),e._v(" 2.1.6 Introduction to Boolean Algebra")]),e._v(" "),n("p",[e._v("Since binary values are at the core of how computers encode, store, and manipulate information, a rich body of mathematical knowledge has evolved around the\nstudy of the values 0 and 1. This started with the work of George Boole (1815–\n1864) around 1850 and thus is known as Boolean algebra. Boole observed that by\nencoding logic values true and false as binary values 1 and 0, he could formulate\nan algebra that captures the basic principles of logical reasoning.")]),e._v(" "),n("p",[e._v("The simplest Boolean algebra is defined over the two-element set {0, 1}.\nFigure 2.7 defines several operations in this algebra. Our symbols for representing\nthese operations are chosen to match those used by the C bit-level operations,as will be discussed later. The Boolean operation ~ corresponds to the logical\noperation not, denoted by the symbol ¬. That is, we say that ¬P is true when\nP is not true, and vice versa. Correspondingly, ~p equals 1 when p equals 0, and\nvice versa. Boolean operation & corresponds to the logical operation and, denoted\nby the symbol ∧. We say that P ∧ Q holds when both P is true and Q is true.\nCorrespondingly, p & q equals 1 only when p = 1 and q = 1. Boolean operation\n| corresponds to the logical operation or, denoted by the symbol ∨. We say that\nP ∨ Q holds when either P is true or Q is true. Correspondingly, p | q equals\n1 when either p = 1 or q = 1. Boolean operation ^ corresponds to the logical\noperation exclusive-or, denoted by the symbol ⊕. We say that P ⊕ Q holds when\neither P is true or Q is true, but not both. Correspondingly, p ^ q equals 1 when\neither p = 1 and q = 0, or p = 0 and q = 1.")]),e._v(" "),n("p",[e._v("Claude Shannon (1916–2001), who later founded the field of information\ntheory, first made the connection between Boolean algebra and digital logic. In\nhis 1937 master’s thesis, he showed that Boolean algebra could be applied to the\ndesign and analysis of networks of electromechanical relays. Although computer\ntechnology has advanced considerably since, Boolean algebra still plays a central\nrole in the design and analysis of digital systems.")]),e._v(" "),n("p",[e._v("We can extend the four Boolean operations to also operate on bit vectors,\nstrings of zeros and ones of some fixed length w. We define the operations over bit\nvectors according to their applications to the matching elements of the arguments.\nLet a and b denote the bit vectors [aw−1, aw−2,...,a0] and [bw−1, bw−2,...,b0],\nrespectively. We define a & b to also be a bit vector of length w, where the ith\nelement equals ai & bi, for "),n("code",[e._v("0 ≤ i<w")]),e._v(". The operations |, ^, and ~ are extended to\nbit vectors in a similar fashion.")]),e._v(" "),n("p",[e._v("As examples, consider the case where w = 4, and with arguments a = "),n("code",[e._v("[0110]")]),e._v("\nand b = "),n("code",[e._v("[1100]")]),e._v(". Then the four operations a & b, a | b, a ^ b, and ~b yield")]),e._v(" "),n("p",[e._v("One useful application of bit vectors is to represent finite sets. We can encode\nany subset A ⊆ {0, 1,...,w − 1} with a bit vector [aw−1,...,a1, a0], where ai = 1if\nand only if i ∈ A. For example, recalling that we write aw−1 on the left and a0 on the\nright, bit vector a = "),n("code",[e._v("[01101001]")]),e._v("encodes the set A = {0, 3, 5, 6}, while bit vector b =\n"),n("code",[e._v("[01010101]")]),e._v("encodes the setB = {0, 2, 4, 6}. With this way of encoding sets, Boolean\noperations | and & correspond to set union and intersection, respectively, and ~\ncorresponds to set complement. Continuing our earlier example, the operation\na & b yields bit vector "),n("code",[e._v("[01000001]")]),e._v(", while A ∩ B = {0, 6}.")]),e._v(" "),n("p",[e._v("We will see the encoding of sets by bit vectors in a number of practical\napplications. For example, in Chapter 8, we will see that there are a number of\ndifferent signals that can interrupt the execution of a program. We can selectively\nenable or disable different signals by specifying a bit-vector mask, where a 1 in\nbit position i indicates that signal i is enabled and a 0 indicates that it is disabled.\nThus, the mask represents the set of enabled signals.")]),e._v(" "),n("p",[e._v("One useful feature of C is that it supports bitwise Boolean operations. In fact, the\nsymbols we have used for the Boolean operations are exactly those used by C:\n| for or, & for and, ~ for not, and ^ for exclusive-or. These can be applied to\nany “integral” data type, including all of those listed in Figure 2.3. Here are some\nexamples of expression evaluation for data type char:")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("C expression")]),e._v(" "),n("th",[e._v("Binary expression")]),e._v(" "),n("th",[e._v("Binary result")]),e._v(" "),n("th",[e._v("Hexadecimal result")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("~0x41")]),e._v(" "),n("td",[e._v("~[0100 0001]")]),e._v(" "),n("td",[e._v("[1011 1110]")]),e._v(" "),n("td",[e._v("0xBE")])]),e._v(" "),n("tr",[n("td",[e._v("~0x00")]),e._v(" "),n("td",[e._v("~[0000 0000]")]),e._v(" "),n("td",[e._v("[1111 1111]")]),e._v(" "),n("td",[e._v("0xFF")])]),e._v(" "),n("tr",[n("td",[e._v("0x69 & 0x55")]),e._v(" "),n("td",[e._v("[0110 1001] & [0101 0101]")]),e._v(" "),n("td",[e._v("[0100 0001]")]),e._v(" "),n("td",[e._v("0x41")])]),e._v(" "),n("tr",[n("td",[e._v("0x69 "),n("code",[e._v("|")]),e._v(" 0x55")]),e._v(" "),n("td",[e._v("[0110 1001] "),n("code",[e._v("|")]),e._v(" [0101 0101]")]),e._v(" "),n("td",[e._v("[0111 1101]")]),e._v(" "),n("td",[e._v("0x7D")])])])]),e._v(" "),n("p",[e._v("As our examples show, the best way to determine the effect of a bit-level expression is to expand the hexadecimal arguments to their binary representations,\nperform the operations in binary, and then convert back to hexadecimal.")]),e._v(" "),n("p",[e._v("One common use of bit-level operations is to implement masking operations,\nwhere a mask is a bit pattern that indicates a selected set of bits within a word. As\nan example, the mask 0xFF (having ones for the least significant 8 bits) indicates\nthe low-order byte of a word. The bit-level operation x & 0xFF yields a value\nconsisting of the least significant byte of x, but with all other bytes set to 0. For\nexample, with x = 0x89ABCDEF, the expression would yield 0x000000EF. The\nexpression ~0 will yield a mask of all ones, regardless of the size of the data\nrepresentation. The same mask can be written 0xFFFFFFFF when data type int is\n32 bits, but it would not be as portable.")]),e._v(" "),n("h2",{attrs:{id:"_2-1-8-logical-operations-in-c"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-8-logical-operations-in-c"}},[e._v("#")]),e._v(" 2.1.8 Logical Operations in C")]),e._v(" "),n("p",[e._v("C also provides a set of logical operators ||, &&, and !, which correspond to the\nor, and, and not operations of logic. These can easily be confused with the bitlevel operations, but their behavior is quite different. The logical operations treat\nany nonzero argument as representing true and argument 0 as representing false.\nThey return either 1 or 0, indicating a result of either true or false, respectively.\nHere are some examples of expression evaluation:")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Expression")]),e._v(" "),n("th",[e._v("Result")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("!0x41")]),e._v(" "),n("td",[e._v("0x00")])]),e._v(" "),n("tr",[n("td",[e._v("!0x00")]),e._v(" "),n("td",[e._v("0x01")])]),e._v(" "),n("tr",[n("td",[e._v("!!0x41")]),e._v(" "),n("td",[e._v("0x01")])]),e._v(" "),n("tr",[n("td",[e._v("0x69 && 0x55")]),e._v(" "),n("td",[e._v("0x01")])]),e._v(" "),n("tr",[n("td",[e._v("0x69 "),n("code",[e._v("||")]),e._v(" 0x55")]),e._v(" "),n("td",[e._v("0x01")])])])]),e._v(" "),n("p",[e._v("Observe that a bitwise operation will have behavior matching that of its logical\ncounterpart only in the special case in which the arguments are restricted to 0\nor 1.")]),e._v(" "),n("p",[e._v("A second important distinction between the logical operators ‘&&’ and ‘||’\nversus their bit-level counterparts ‘&’ and ‘|’ is that the logical operators do not\nevaluate their second argument if the result of the expression can be determined\nby evaluating the first argument. Thus, for example, the expression a && 5/a will\nnever cause a division by zero, and the expression p && *p++ will never cause the\ndereferencing of a null pointer.")]),e._v(" "),n("h2",{attrs:{id:"_2-1-9-shift-operations-in-c"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-9-shift-operations-in-c"}},[e._v("#")]),e._v(" 2.1.9 Shift Operations in C")]),e._v(" "),n("p",[e._v("C also provides a set of shift operations for shifting bit patterns to the left and to\nthe right. For an operand x having bit representation [xw−1, xw−2,...,x0], the C\nexpression x << k yields a value with bit representation [xw−k−1, xw−k−2,...,x0,\n0,..., 0]. That is, x is shifted k bits to the left, dropping off the k most significant\nbits and filling the right end with k zeros. The shift amount should be a value\nbetween 0 and w − 1. Shift operations associate from left to right, so x << j << k\nis equivalent to (x << j) << k.There is a corresponding right shift operation, written in C as x >> k, but it has\na slightly subtle behavior. Generally, machines support two forms of right shift:")]),e._v(" "),n("ul",[n("li",[e._v("Logical. A logical right shift fills the left end with k zeros, giving a result\n[0,..., 0, xw−1, xw−2,...xk].")]),e._v(" "),n("li",[e._v("Arithmetic. An arithmetic right shift fills the left end with k repetitions of the\nmost significant bit, giving a result [xw−1,...,xw−1, xw−1, xw−2,...xk].\nThis convention might seem peculiar, but as we will see, it is useful for\noperating on signed integer data.")])]),e._v(" "),n("p",[e._v("As examples, the following table shows the effect of applying the different\nshift operations to two different values of an 8-bit argument x:")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Operation")]),e._v(" "),n("th",[e._v("Value 1")]),e._v(" "),n("th",[e._v("Value 2")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("Argument x")]),e._v(" "),n("td",[n("code",[e._v("[01100011]")])]),e._v(" "),n("td",[n("code",[e._v("[10010101]")])])]),e._v(" "),n("tr",[n("td",[e._v("x << 4")]),e._v(" "),n("td",[n("code",[e._v("[00110000]")])]),e._v(" "),n("td",[n("code",[e._v("[01010000]")])])]),e._v(" "),n("tr",[n("td",[e._v("x >> 4 (logical)")]),e._v(" "),n("td",[n("code",[e._v("[00000110]")])]),e._v(" "),n("td",[n("code",[e._v("[00001001]")])])]),e._v(" "),n("tr",[n("td",[e._v("x >> 4 (arithmetic)")]),e._v(" "),n("td",[n("code",[e._v("[00000110]")])]),e._v(" "),n("td",[n("code",[e._v("[11111001]")])])])])]),e._v(" "),n("p",[e._v("The italicized digits indicate the values that fill the right (left shift) or left (right\nshift) ends. Observe that all but one entry involves filling with zeros. The exception\nis the case of shifting "),n("code",[e._v("[10010101]")]),e._v(" right arithmetically. Since its most significant bit\nis 1, this will be used as the fill value.")]),e._v(" "),n("p",[e._v("The C standards do not precisely define which type of right shift should be\nused with signed numbers—either arithmetic or logical shifts may be used. This\nunfortunately means that any code assuming one form or the other will potentially\nencounter portability problems. In practice, however, almost all compiler/machine\ncombinations use arithmetic right shifts for signed data, and many programmers\nassume this to be the case. For unsigned data, on the other hand, right shifts must\nbe logical.")]),e._v(" "),n("p",[e._v("In contrast to C, Java has a precise definition of how right shifts should be\nperformed. The expression x >> k shifts x arithmetically by k positions, while\nx >>> k shifts it logically.")]),e._v(" "),n("p",[e._v("Figure 2.14 shows the bit patterns and numeric values for several important\nnumbers for different word sizes. The first three give the ranges of representable\nintegers in terms of the values of UMaxw, TMinw, and TMaxw. We will refer\nto these three special values often in the ensuing discussion. We will drop the\nsubscript w and refer to the values UMax, TMin, andTMax when w can be inferred\nfrom context or is not central to the discussion.")]),e._v(" "),n("p",[e._v("A few points are worth highlighting about these numbers. First, as observed\nin Figures 2.9 and 2.10, the two’s-complement range is asymmetric: |TMin| =\n|TMax| + 1; that is, there is no positive counterpart to TMin. As we shall see, this\nleads to some peculiar properties of two’s-complement arithmetic and can be the\nsource of subtle program bugs. This asymmetry arises because half the bit patterns\n(those with the sign bit set to 1) represent negative numbers, while half (those\nwith the sign bit set to 0) represent nonnegative numbers. Since 0 is nonnegative,\nthis means that it can represent one less positive number than negative. Second,\nthe maximum unsigned value is just over twice the maximum two’s-complement\nvalue: UMax = 2TMax + 1. All of the bit patterns that denote negative numbers in\ntwo’s-complement notation become positive values in an unsigned representation. Figure 2.14 also shows the representations of constants −1 and 0. Note that −1\nhas the same bit representation as UMax—a string of all ones. Numeric value 0 is\nrepresented as a string of all zeros in both representations.")]),e._v(" "),n("p",[e._v("The C standards do not require signed integers to be represented in two’scomplement form, but nearly all machines do so. Programmers who are concerned\nwith maximizing portability across all possible machines should not assume any\nparticular range of representable values, beyond the ranges indicated in Figure\n2.11, nor should they assume any particular representation of signed numbers.\nOn the other hand, many programs are written assuming a two’s-complement\nrepresentation of signed numbers, and the “typical” ranges shown in Figures 2.9\nand 2.10, and these programs are portable across a broad range of machines\nand compilers. The file <limits.h> in the C library defines a set of constants delimiting the ranges of the different integer data types for the particular machine\non which the compiler is running. For example, it defines constants INT_MAX, INT_\nMIN, and UINT_MAX describing the ranges of signed and unsigned integers. For a\ntwo’s-complement machine in which data type int has w bits, these constants\ncorrespond to the values of TMaxw, TMinw, and UMaxw.")])])}),[],!1,null,null,null);t.default=s.exports}}]);