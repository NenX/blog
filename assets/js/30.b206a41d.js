(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{387:function(e,t,n){"use strict";n.r(t);var s=n(42),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_2-2-integer-representations"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-integer-representations"}},[e._v("#")]),e._v(" 2.2 Integer Representations")]),e._v(" "),n("p",[e._v("In this section, we describe two different ways bits can be used to encode integers—one that can only represent nonnegative numbers, and one that can represent negative, zero, and positive numbers. We will see later that they are strongly related both in their mathematical properties and their machine-level implementations. We also investigate the effect of expanding or shrinking an encoded integer to fit a representation with a different length.")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Symbol")]),e._v(" "),n("th",[e._v("Type")]),e._v(" "),n("th",[e._v("Meaning")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("B2T"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Function")]),e._v(" "),n("td",[e._v("Binary to two’s complement")])]),e._v(" "),n("tr",[n("td",[e._v("B2U"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Function")]),e._v(" "),n("td",[e._v("Binary to unsigned")])]),e._v(" "),n("tr",[n("td",[e._v("U2B"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Function")]),e._v(" "),n("td",[e._v("Unsigned to binary")])]),e._v(" "),n("tr",[n("td",[e._v("U2T"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Function")]),e._v(" "),n("td",[e._v("Unsigned to two’s complement")])]),e._v(" "),n("tr",[n("td",[e._v("T2B"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Function")]),e._v(" "),n("td",[e._v("Two’s complement to binary")])]),e._v(" "),n("tr",[n("td",[e._v("T2U"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Function")]),e._v(" "),n("td",[e._v("Two’s complement to unsigned")])]),e._v(" "),n("tr",[n("td",[e._v("TMin"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Constant")]),e._v(" "),n("td",[e._v("Minimum two’s-complement value")])]),e._v(" "),n("tr",[n("td",[e._v("TMax"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Constant")]),e._v(" "),n("td",[e._v("Maximum two’s-complement value")])]),e._v(" "),n("tr",[n("td",[e._v("UMax"),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Constant")]),e._v(" "),n("td",[e._v("Maximum unsigned value")])]),e._v(" "),n("tr",[n("td",[e._v("+"),n("sup",[e._v("t")]),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Operation")]),e._v(" "),n("td",[e._v("Two’s-complement addition")])]),e._v(" "),n("tr",[n("td",[e._v("+"),n("sup",[e._v("u")]),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Operation")]),e._v(" "),n("td",[e._v("Unsigned addition")])]),e._v(" "),n("tr",[n("td",[e._v("*"),n("sup",[e._v("t")]),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Operation")]),e._v(" "),n("td",[e._v("Two’s-complement multiplication")])]),e._v(" "),n("tr",[n("td",[e._v("*"),n("sup",[e._v("u")]),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Operation")]),e._v(" "),n("td",[e._v("Unsigned multiplication")])]),e._v(" "),n("tr",[n("td",[e._v("-"),n("sup",[e._v("t")]),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Operation")]),e._v(" "),n("td",[e._v("Two’s-complement negation")])]),e._v(" "),n("tr",[n("td",[e._v("-"),n("sup",[e._v("u")]),n("sub",[e._v("w")])]),e._v(" "),n("td",[e._v("Operation")]),e._v(" "),n("td",[e._v("Unsigned negation")])])])]),e._v(" "),n("p",[e._v("terminology will be introduced over the course of the presentation. The figure is\nincluded here as a reference.")]),e._v(" "),n("h2",{attrs:{id:"_2-2-1-integral-data-types"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-integral-data-types"}},[e._v("#")]),e._v(" 2.2.1 Integral Data Types")]),e._v(" "),n("p",[e._v("C supports a variety of integral data types—ones that represent finite ranges of\nintegers. These are shown in Figures 2.9 and 2.10, along with the ranges of values\nthey can have for “typical” 32- and 64-bit programs. Each type can specify a\nsize with keyword char, short, long, as well as an indication of whether the\nrepresented numbers are all nonnegative (declared as unsigned), or possibly\nnegative (the default.) As we saw in Figure 2.3, the number of bytes allocated for\nthe different sizes varies according to whether the program is compilfed for 32 or\n64 bits. Based on the byte allocations, the different sizes allow diferent ranges of\nvalues to be represented. The only machine-dependent range indicated is for size\ndesignator long. Most 64-bit programs use an 8-byte representation, giving a much\nwider range of values than the 4-byte representation used with 32-bit programs.")]),e._v(" "),n("p",[e._v("The C standards define minimum ranges of values that each data type must\nbe able to represent. As shown in Figure 2.11, their ranges are the same or smaller\nthan the typical implementations shown in Figures 2.9 and 2.10. In particular,\nwith the exception of the fixed-size data types, we see that they require only a symmetric range of positive and negative numbers. We also see that data type int\ncould be implemented with 2-byte numbers, although this is mostly a throwback\nto the days of 16-bit machines. We also see that size long can be implemented\nwith 4-byte numbers, and it typically is for 32-bit programs. The fixed-size data\ntypes guarantee that the ranges of values will be exactly those given by the typical\nnumbers of Figure 2.9, including the asymmetry between negative and positive.")]),e._v(" "),n("h2",{attrs:{id:"_2-2-2-unsigned-encodings"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-unsigned-encodings"}},[e._v("#")]),e._v(" 2.2.2 Unsigned Encodings")]),e._v(" "),n("p",[e._v("Let us consider an integer data type of w bits. We write a bit vector as either x\f, to\ndenote the entire vector, or as [x"),n("sub",[e._v("w−1")]),e._v(", x"),n("sub",[e._v("w−2")]),e._v(",...,x"),n("sub",[e._v("0")]),e._v("] to denote the individual bits\nwithin the vector. Treating x\f as a number written in binary notation, we obtain the\nunsigned interpretation of x\f. In this encoding, each bit x"),n("sub",[e._v("i")]),e._v(" has value 0 or 1, with the\nlatter case indicating that value 2"),n("sup",[e._v("i")]),e._v(" should be included as part of the numeric value.\nWe can express this interpretation as a function B2U"),n("sub",[e._v("w")]),e._v(" (for “binary to unsigned,”\nlength w):")]),e._v(" "),n("p",[e._v("In this equation, the notation .\n= means that the left-hand side is defined to be\nequal to the right-hand side. The function B2Uw maps strings of zeros and ones\nof length w to nonnegative integers. As examples, Figure 2.12 shows the mapping,\ngiven by B2U, from bit vectors to integers for the following cases:")]),e._v(" "),n("blockquote",[n("p",[n("code",[e._v("B2U4([0001])")]),e._v(" = 0 . 2"),n("sup",[e._v("3")]),e._v(" + 0 . 2"),n("sup",[e._v("2")]),e._v(" + 0 . 2"),n("sup",[e._v("1")]),e._v(" + 1 . 2"),n("sup",[e._v("0")]),e._v(" = 0 + 0 + 0 + 1 = 1")]),e._v(" "),n("p",[n("code",[e._v("B2U4([0101])")]),e._v(" = 0 . 2"),n("sup",[e._v("3")]),e._v(" + 1 . 2"),n("sup",[e._v("2")]),e._v(" + 0 . 2"),n("sup",[e._v("1")]),e._v(" + 1 . 2"),n("sup",[e._v("0")]),e._v(" = 0 + 4 + 0 + 1 = 5")]),e._v(" "),n("p",[n("code",[e._v("B2U4([1011])")]),e._v(" = 1 . 2"),n("sup",[e._v("3")]),e._v(" + 0 . 2"),n("sup",[e._v("2")]),e._v(" + 1 . 2"),n("sup",[e._v("1")]),e._v(" + 1 . 2"),n("sup",[e._v("0")]),e._v(" = 8 + 0 + 2 + 1 = 11")]),e._v(" "),n("p",[n("code",[e._v("B2U4([1111])")]),e._v(" = 1 . 2"),n("sup",[e._v("3")]),e._v(" + 1 . 2"),n("sup",[e._v("2")]),e._v(" + 1 . 2"),n("sup",[e._v("1")]),e._v(" + 1 . 2"),n("sup",[e._v("0")]),e._v(" = 8 + 4 + 2 + 1 = 15")])]),e._v(" "),n("p",[e._v("In the figure, we represent each bit position i by a rightward-pointing blue bar of\nlength 2"),n("sup",[e._v("i")]),e._v(". The numeric value associated with a bit vector then equals the sum of\nthe lengths of the bars for which the corresponding bit values are 1.")]),e._v(" "),n("p",[e._v("Let us consider the range of values that can be represented using w bits. The\nleast value is given by bit vector [00 ... 0] having integer value 0, and the greatest\nvalue is given by bit vector [11 ... 1] having integer value UMax"),n("sub",[e._v("w")]),e._v(" = 2"),n("sup",[e._v("w")]),e._v(" − 1. Using the 4-bit case as an example,\nwe have UMax"),n("sub",[e._v("4")]),e._v(" = B2U"),n("sub",[e._v("4")]),e._v("([1111]) = 24 − 1= 15. Thus, the function B2Uw can be defined as a mapping B2U"),n("sub",[e._v("w")]),e._v(":{0, 1}w →{0,..., UMaxw}.")]),e._v(" "),n("p",[e._v("The unsigned binary representation has the important property that every\nnumber between 0 and 2"),n("sup",[e._v("w")]),e._v(" − 1has a unique encoding as a w-bit value. For example, there is only one representation of decimal value 11 as an unsigned 4-bit number—\nnamely, [1011]. We highlight this as a mathematical principle, which we first state\nand then explain.")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("principle")]),e._v(" "),n("p",[e._v("Uniqueness of unsigned encoding: Function B2U"),n("sub",[e._v("w")]),e._v(" is a bijection.")])]),e._v(" "),n("p",[e._v("The mathematical term bijection refers to a function f that goes two ways:\nit maps a value x to a value y where y = f (x), but it can also operate in reverse,\nsince for every y, there is a unique value x such that f (x) = y. This is given by\nthe inverse function f −1, where, for our example, x = f −1(y). The function B2U"),n("sub",[e._v("w")]),e._v("\nmaps each bit vector of length w to a unique number between 0 and 2"),n("sup",[e._v("w")]),e._v(" − 1, and\nit has an inverse, which we call U2B"),n("sub",[e._v("w")]),e._v(" (for “unsigned to binary”), that maps each\nnumber in the range 0 to 2"),n("sup",[e._v("w")]),e._v(" − 1 to a unique pattern of w bits.")]),e._v(" "),n("h2",{attrs:{id:"_2-2-3-two-s-complement-encodings"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-two-s-complement-encodings"}},[e._v("#")]),e._v(" 2.2.3 Two’s-Complement Encodings")]),e._v(" "),n("p",[e._v("For many applications, we wish to represent negative values as well. The most common computer representation of signed numbers is known as two’s-complement\nform. This is defined by interpreting the most significant bit of the word to have\nnegative weight. We express this interpretation as a function B2T"),n("sub",[e._v("w")]),e._v(" (for “binary\nto two’s complement” length w):")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("principle Definition of two’s-complement encoding")]),e._v(" "),n("p",[e._v("For vector x\f = [x"),n("sub",[e._v("w−1")]),e._v(", x"),n("sub",[e._v("w−2")]),e._v(",...,x0]:")])]),e._v(" "),n("p",[e._v("The most significant bit x"),n("sub",[e._v("w−1")]),e._v(" is also called the sign bit. Its “weight” is −2"),n("sup",[e._v("w−1")]),e._v(",\nthe negation of its weight in an unsigned representation. When the sign bit is set\nto 1, the represented value is negative, and when set to 0, the value is nonnegative.\nAs examples, Figure 2.13 shows the mapping, given by B2T, from bit vectors to\nintegers for the following cases:")]),e._v(" "),n("blockquote",[n("p",[n("code",[e._v("B2T4([0001])")]),e._v(" = −0 . 2"),n("sup",[e._v("3")]),e._v(" + 0 . 2"),n("sup",[e._v("2")]),e._v(" + 0 . 2"),n("sup",[e._v("1")]),e._v(" + 1 . 2"),n("sup",[e._v("0")]),e._v(" = 0 + 0 + 0 + 1 = 1")]),e._v(" "),n("p",[n("code",[e._v("B2T4([0101])")]),e._v(" = −0 . 2"),n("sup",[e._v("3")]),e._v(" + 1 . 2"),n("sup",[e._v("2")]),e._v(" + 0 . 2"),n("sup",[e._v("1")]),e._v(" + 1 . 2"),n("sup",[e._v("0")]),e._v(" = 0 + 4 + 0 + 1 = 5")]),e._v(" "),n("p",[n("code",[e._v("B2T4([1011])")]),e._v(" = −1 . 2"),n("sup",[e._v("3")]),e._v(" + 0 . 2"),n("sup",[e._v("2")]),e._v(" + 1 . 2"),n("sup",[e._v("1")]),e._v(" + 1 . 2"),n("sup",[e._v("0")]),e._v(" = −8 + 0 + 2 + 1 = −5")]),e._v(" "),n("p",[n("code",[e._v("B2T4([1111])")]),e._v(" = −1 . 2"),n("sup",[e._v("3")]),e._v(" + 1 . 2"),n("sup",[e._v("2")]),e._v(" + 1 . 2"),n("sup",[e._v("1")]),e._v(" + 1 . 2"),n("sup",[e._v("0")]),e._v(" = −8 + 4 + 2 + 1 = −1")])]),e._v(" "),n("p",[e._v("In the figure, we indicate that the sign bit has negative weight by showing it as\na leftward-pointing gray bar. The numeric value associated with a bit vector is\nthen given by the combination of the possible leftward-pointing gray bar and the\nrightward-pointing blue bars.")]),e._v(" "),n("p",[e._v("We see that the bit patterns are identical for Figures 2.12 and 2.13 (as well as\nfor Equations 2.2 and 2.4), but the values differ when the most significant bit is 1,\nsince in one case it has weight +8, and in the other case it has weight −8.")]),e._v(" "),n("p",[e._v("Let us consider the range of values that can be represented as a w-bit two’scomplement number. The least representable value is given by bit vector [10 ... 0]\n(set the bit with negative weight but clear all others), having integer value\nTMin"),n("sub",[e._v("w−2")]),e._v(" = −2"),n("sup",[e._v("w−1")]),e._v(". The greatest value is given by bit vector [01 ... 1] (clear the bit\nwith negative weight but set all others), having integer value TMax"),n("sub",[e._v("w")]),e._v("=2"),n("sup",[e._v("w−1")]),e._v(" − 1. Using the 4-bit case as an example,\nwe have TMin"),n("sub",[e._v("4")]),e._v(" = B2T"),n("sub",[e._v("4")]),e._v("([1000]) = −2"),n("sup",[e._v("3")]),e._v(" = −8 and TMax4 = B2T4([0111]) = 2"),n("sup",[e._v("3")]),e._v(" -1 = 7.")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("principle")]),e._v(" "),n("p",[e._v("Uniqueness of signed encoding: Function B2T"),n("sub",[e._v("w")]),e._v(" is a bijection.")])]),e._v(" "),n("p",[e._v("We define function T2B"),n("sub",[e._v("w")]),e._v(" (for “two’s complement to binary”) to be the inverse\nof B2T"),n("sub",[e._v("w")]),e._v(". That is, for a number x, such that TMin"),n("sub",[e._v("w")]),e._v(" ≤ x ≤ TMax"),n("sub",[e._v("w")]),e._v(", T2B"),n("sub",[e._v("w")]),e._v("(x) is the (unique) w-bit pattern that encodes x.")]),e._v(" "),n("p",[e._v("Figure 2.14 shows the bit patterns and numeric values for several important\nnumbers for different word sizes. The first three give the ranges of representable\nintegers in terms of the values of UMaxw, TMinw, and TMaxw. We will refer\nto these three special values often in the ensuing discussion. We will drop the\nsubscript w and refer to the values UMax, TMin, andTMax when w can be inferred\nfrom context or is not central to the discussion.")]),e._v(" "),n("p",[e._v("A few points are worth highlighting about these numbers. First, as observed\nin Figures 2.9 and 2.10, the two’s-complement range is asymmetric: |TMin| =\n|TMax| + 1; that is, there is no positive counterpart to TMin. As we shall see, this\nleads to some peculiar properties of two’s-complement arithmetic and can be the\nsource of subtle program bugs. This asymmetry arises because half the bit patterns\n(those with the sign bit set to 1) represent negative numbers, while half (those\nwith the sign bit set to 0) represent nonnegative numbers. Since 0 is nonnegative,\nthis means that it can represent one less positive number than negative. Second,\nthe maximum unsigned value is just over twice the maximum two’s-complement\nvalue: UMax = 2TMax + 1. All of the bit patterns that denote negative numbers in\ntwo’s-complement notation become positive values in an unsigned representation.Figure 2.14 also shows the representations of constants −1 and 0. Note that −1\nhas the same bit representation as UMax—a string of all ones. Numeric value 0 is\nrepresented as a string of all zeros in both representations.")]),e._v(" "),n("p",[e._v("The C standards do not require signed integers to be represented in two’scomplement form, but nearly all machines do so. Programmers who are concerned\nwith maximizing portability across all possible machines should not assume any\nparticular range of representable values, beyond the ranges indicated in Figure\n2.11, nor should they assume any particular representation of signed numbers.\nOn the other hand, many programs are written assuming a two’s-complement\nrepresentation of signed numbers, and the “typical” ranges shown in Figures 2.9\nand 2.10, and these programs are portable across a broad range of machines\nand compilers. The file <limits.h> in the C library defines a set of constants delimiting the ranges of the different integer data types for the particular machine\non which the compiler is running. For example, it defines constants INT_MAX, INT_\nMIN, and UINT_MAX describing the ranges of signed and unsigned integers. For a\ntwo’s-complement machine in which data type int has w bits, these constants\ncorrespond to the values of TMaxw, TMinw, and UMaxw.")]),e._v(" "),n("p",[e._v("The Java standard is quite specific about integer data type ranges and representations. It requires a two’s-complement representation with the exact ranges\nshown for the 64-bit case (Figure 2.10). In Java, the single-byte data type is called\nbyte instead of char. These detailed requirements are intended to enable Java\nprograms to behave identically regardless of the machines or operating systems\nrunning them.")]),e._v(" "),n("p",[e._v("When run on a big-endian machine, this code prints 30 39 and cf c7, indicating that x has hexadecimal representation 0x3039, while mx has hexadecimal representation 0xCFC7. Expanding these into binary, we get bit patterns\n[0011000000111001] for x and [1100111111000111] for mx. As Figure 2.15 shows,\nEquation 2.3 yields values 12,345 and −12,345 for these two bit patterns.")]),e._v(" "),n("h2",{attrs:{id:"_2-2-4-conversions-between-signed-and-unsigned"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-conversions-between-signed-and-unsigned"}},[e._v("#")]),e._v(" 2.2.4 Conversions between Signed and Unsigned")]),e._v(" "),n("p",[e._v("C allows casting between different numeric data types. For example, suppose\nvariable x is declared as int and u as unsigned. The expression "),n("code",[e._v("(unsigned) x")]),e._v("\nconverts the value of x to an unsigned value, and "),n("code",[e._v("(int) u")]),e._v(" converts the value of u\nto a signed integer. What should be the effect of casting signed value to unsigned,\nor vice versa? From a mathematical perspective, one can imagine several different\nconventions. Clearly, we want to preserve any value that can be represented in\nboth forms. On the other hand, converting a negative value to unsigned might yield\nzero. Converting an unsigned value that is too large to be represented in two’scomplement form might yield TMax. For most implementations of C, however,\nthe answer to this question is based on a bit-level perspective, rather than on a\nnumeric one.")]),e._v(" "),n("p",[e._v("For example, consider the following code:")]),e._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" v "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("12345")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),e._v(" uv "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"v = %d, uv = %u\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" uv"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),n("p",[e._v("When run on a two’s-complement machine, it generates the following output:"),n("code",[e._v("v = -12345, uv = 53191")])]),e._v(" "),n("p",[e._v("What we see here is that the effect of casting is to keep the bit values identical\nbut change how these bits are interpreted. We saw in Figure 2.15 that the 16-bit\ntwo’s-complement representation of −12,345 is identical to the 16-bit unsigned\nrepresentation of 53,191. Casting from short to unsigned short changed the\nnumeric value, but not the bit representation. Similarly, consider the following code:")]),e._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" u "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("4294967295u")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* UMax */")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" tu "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"u = %u, tu = %d\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" tu"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n")])])]),n("p",[e._v("When run on a two’s-complement machine, it generates the following output: "),n("code",[e._v("u = 4294967295, tu = -1")])]),e._v(" "),n("p",[e._v("We can see from Figure 2.14 that, for a 32-bit word size, the bit patterns representing 4,294,967,295 (UMax32) in unsigned form and −1 in two’s-complement form\nare identical. In casting from unsigned to int, the underlying bit representation stays the same.")]),e._v(" "),n("p",[e._v("This is a general rule for how most C implementations handle conversions\nbetween signed and unsigned numbers with the same word size—the numeric\nvalues might change, but the bit patterns do not. Let us capture this idea in\na more mathematical form. We defined functions U2Bw and T2Bw that map\nnumbers to their bit representations in either unsigned or two’s-complement form.\nThat is, given an integer x in the range 0 ≤ x < UMaxw, the function U2Bw(x)\ngives the unique w-bit unsigned representation of x. Similarly, when x is in the\nrange TMinw ≤ x ≤ TMaxw, the function T2Bw(x) gives the unique w-bit two’scomplement representation of x.")]),e._v(" "),n("p",[e._v("Now define the function T2Uw as T2Uw(x) = B2Uw(T2Bw(x)). This function\ntakes a number between TMinw and TMaxw and yields a number between 0 and\nUMaxw, where the two numbers have identical bit representations, except that\nthe argument has a two’s-complement representation while the result is unsigned.\nSimilarly, for x between 0 and UMaxw, the function U2Tw, defined as U2Tw(x) = B2Tw(U2Bw(x)), yields the number having the same two’s-complement representation as the unsigned representation of x.")]),e._v(" "),n("p",[e._v("Pursuing our earlier examples, we see from Figure 2.15 that T2U16(−12,345) = 53,191, and that U2T16(53,191) = −12,345. That is, the 16-bit pattern written in\nhexadecimal as 0xCFC7 is both the two’s-complement representation of −12,345 and the unsigned representation of 53,191. Note also that 12,345 + 53,191 = 65,536 = 2"),n("sup",[e._v("16")]),e._v(". This property generalizes to a relationship between the two numeric values (two’s complement and unsigned) represented by a given bit pattern. Similarly, from Figure 2.14, we see that T2U32(−1) = 4,294,967,295, and U2T32(4,294,967,295) = −1. That is, UMax has the same bit representation in unsigned form as does−1 in two’s-complement form. We can also see the relationship between these two numbers: 1 + UMaxw = 2w.")]),e._v(" "),n("p",[e._v("We see, then, that function T2U describes the conversion of a two’scomplement number to its unsigned counterpart, while U2T converts in the opposite direction. These describe  the effect of casting between these data types in most C implementations.")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("principle: Conversion from two’s complement to unsigned")]),e._v(" "),n("p",[e._v("For x such that TMinw ≤ x ≤ TMaxw: T2U"),n("sub",[e._v("w")]),e._v("(x) = x >=0 ? (x + 2"),n("sup",[e._v("w")]),e._v("):(x)")])]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("derivation: Conversion from two’s complement to unsigned")]),e._v(" "),n("p",[e._v("Comparing Equations 2.1 and 2.3, we can see that for bit pattern x\f, if we compute\nthe difference B2Uw(x)\f − B2Tw(x)\f , the weighted sums for bits from 0 to w − 2 will\ncancel each other, leaving a value B2Uw(x)\f − B2Tw(x)\f = xw−1(2w−1 − −2w−1) =\nxw−12w. This gives a relationship B2Uw(x)\f = B2Tw(x)\f + xw−12w. We therefore have:"),n("code",[e._v("B2Uw(T2Bw(x)) = T2Uw(x) = x + xw−12w")])])]),e._v(" "),n("p",[e._v("In a two’s-complement representation of x, bit xw−1 determines whether or not x\nis negative, giving the two cases of Equation 2.5")]),e._v(" "),n("p",[e._v("As examples, Figure 2.16 compares how functions B2U and B2T assign values\nto bit patterns for w = 4. For the two’s-complement case, the most significant bit\nserves as the sign bit, which we diagram as a leftward-pointing gray bar. For the\nunsigned case, this bit has positive weight, which we show as a rightward-pointing\nblack bar. In going from two’s complement to unsigned, the most significant bit\nchanges its weight from −8 to +8. As a consequence, the values that are negative in a two’s-complement representation increase by 2"),n("sup",[e._v("4")]),e._v(" = 16 with an unsigned\nrepresentation. Thus, −5 becomes +11, and −1 becomes +15.")])])}),[],!1,null,null,null);t.default=a.exports}}]);