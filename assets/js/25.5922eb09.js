(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{383:function(e,t,s){"use strict";s.r(t);var a=s(42),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"_1-7-the-operating-system-manages-the-hardware"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-the-operating-system-manages-the-hardware"}},[e._v("#")]),e._v(" 1.7 The Operating System Manages the Hardware")]),e._v(" "),s("p",[e._v("Back to our hello example. When the shell loaded and ran the hello program,\nand when the hello program printed its message, neither program accessed the\nkeyboard, display, disk, or main memory directly. Rather, they relied on the\nservices provided by the operating system. We can think of the operating system as\na layer of software interposed between the application program and the hardware,\nas shown in Figure 1.10. All attempts by an application program to manipulate the\nhardware must go through the operating system.")]),e._v(" "),s("p",[e._v("The operating system has two primary purposes: (1) to protect the hardware\nfrom misuse by runaway applications and (2) to provide applications with simple\nand uniform mechanisms for manipulating complicated and often wildly different\nlow-level hardware devices. The operating system achieves both goals via the\nfundamental abstractions shown in Figure 1.11: processes, virtual memory, and\nfiles. As this figure suggests, files are abstractions for I/O devices, virtual memory\nis an abstraction for both the main memory and disk I/O devices, and processes\nare abstractions for the processor, main memory, and I/O devices. We will discuss\neach in turn.")]),e._v(" "),s("h2",{attrs:{id:"_1-7-1-processes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-1-processes"}},[e._v("#")]),e._v(" 1.7.1 Processes")]),e._v(" "),s("p",[e._v("When a program such as hello runs on a modern system, the operating system\nprovides the illusion that the program is the only one running on the system. The\nprogram appears to have exclusive use of both the processor, main memory, and\nI/O devices. The processor appears to execute the instructions in the program, one\nafter the other, without interruption. And the code and data of the program appear\nto be the only objects in the system’s memory. These illusions are provided by the\nnotion of a process, one of the most important and successful ideas in computer\nscience.")]),e._v(" "),s("p",[e._v("A process is the operating system’s abstraction for a running program. Multiple processes can run concurrently on the same system, and each process appears to have exclusive use of the hardware. By concurrently, we mean that the instructions of one process are interleaved with the instructions of another process. In most systems, there are more processes to run than there are CPUs to run them.Traditional systems could only execute one program at a time, while newer multicore processors can execute several programs simultaneously. In either case, a single CPU can appear to execute multiple processes concurrently by having the\nprocessor switch among them. The operating system performs this interleaving with a mechanism known as context switching. To simplify the rest of this discussion, we consider only a uniprocessor system containing a single CPU. We will\nreturn to the discussion of multiprocessor systems in Section 1.9.2.")]),e._v(" "),s("p",[e._v("The operating system keeps track of all the state information that the process\nneeds in order to run. This state, which is known as the context, includes information such as the current values of the PC, the register file, and the contents of main memory. At any point in time, a uniprocessor system can only execute the code\nfor a single process. When the operating system decides to transfer control from the current process to some new process, it performs a context switch by saving the context of the current process, restoring the context of the new process, and then passing control to the new process. The new process picks up exactly where it left off. Figure 1.12 shows the basic idea for our example hello scenario.")]),e._v(" "),s("p",[e._v("There are two concurrent processes in our example scenario: the shell process\nand the hello process. Initially, the shell process is running alone, waiting for input\non the command line. When we ask it to run the hello program, the shell carries\nout our request by invoking a special function known as a system call that passes\ncontrol to the operating system. The operating system saves the shell’s context,\ncreates a new hello process and its context, and then passes control to the new\nhello process. After hello terminates, the operating system restores the context\nof the shell process and passes control back to it, where it waits for the next\ncommand-line input.")]),e._v(" "),s("p",[e._v("As Figure 1.12 indicates, the transition from one process to another is managed by the operating system kernel. The kernel is the portion of the operating\nsystem code that is always resident in memory. When an application program\nrequires some action by the operating system, such as to read or write a file, it\nexecutes a special system call instruction, transferring control to the kernel. The\nkernel then performs the requested operation and returns back to the application\nprogram. Note that the kernel is not a separate process. Instead, it is a collection\nof code and data structures that the system uses to manage all the processes.")]),e._v(" "),s("p",[e._v("Implementing the process abstraction requires close cooperation between\nboth the low-level hardware and the operating system software. We will explore\nhow this works, and how applications can create and control their own processes,\nin Chapter 8.")]),e._v(" "),s("h2",{attrs:{id:"_1-7-2-threads"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-2-threads"}},[e._v("#")]),e._v(" 1.7.2 Threads")]),e._v(" "),s("p",[e._v("Although we normally think of a process as having a single control flow, in modern\nsystems a process can actually consist of multiple execution units, called threads,\neach running in the context of the process and sharing the same code and global\ndata. Threads are an increasingly important programming model because of the\nrequirement for concurrency in network servers, because it is easier to share data\nbetween multiple threads than between multiple processes, and because threads\nare typically more efficient than processes. Multi-threading is also one way to make programs run faster when multiple processors are available, as we will discuss in Section 1.9.2. You will learn the basic concepts of concurrency, including how to\nwrite threaded programs, in Chapter 12.")]),e._v(" "),s("h2",{attrs:{id:"_1-7-3-virtual-memory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-3-virtual-memory"}},[e._v("#")]),e._v(" 1.7.3 Virtual Memory")]),e._v(" "),s("p",[e._v("Virtual memory is an abstraction that provides each process with the illusion that it\nhas exclusive use of the main memory. Each process has the same uniform view of\nmemory, which is known as its virtual address space. The virtual address space for\nLinux processes is shown in Figure 1.13. (Other Unix systems use a similar layout.)\nIn Linux, the topmost region of the address space is reserved for code and data\nin the operating system that is common to all processes. The lower region of the\naddress space holds the code and data defined by the user’s process. Note that\naddresses in the figure increase from the bottom to the top.")]),e._v(" "),s("p",[e._v("The virtual address space seen by each process consists of a number of welldefined areas, each with a specific purpose. You will learn more about these areas later in the book, but it will be helpful to look briefly at each, starting with the\nlowest addresses and working our way up:")]),e._v(" "),s("ul",[s("li",[e._v("Program code and data.Code begins at the same fixed address for all processes,\nfollowed by data locations that correspond to global C variables. The code and\ndata areas are initialized directly from the contents of an executable object\nfile—in our case, the hello executable. You will learn more about this part of\nthe address space when we study linking and loading in Chapter 7.")]),e._v(" "),s("li",[e._v("Heap.The code and data areas are followed immediately by the run-time heap.\nUnlike the code and data areas, which are fixed in size once the process begins running, the heap expands and contracts dynamically at run time as a result of calls to C standard library routines such as malloc and free. We will study\nheaps in detail when we learn about managing virtual memory in Chapter 9.\n.")]),e._v(" "),s("li",[e._v("Shared libraries.Near the middle of the address space is an area that holds the\ncode and data for shared libraries such as the C standard library and the math\nlibrary. The notion of a shared library is a powerful but somewhat difficult\nconcept. You will learn how they work when we study dynamic linking in\nChapter 7.")]),e._v(" "),s("li",[e._v("Stack. At the top of the user’s virtual address space is the user stack that\nthe compiler uses to implement function calls. Like the heap, the user stack\nexpands and contracts dynamically during the execution of the program. In\nparticular, each time we call a function, the stack grows. Each time we return\nfrom a function, it contracts. You will learn how the compiler uses the stack\nin Chapter 3.")]),e._v(" "),s("li",[e._v("Kernel virtual memory.The top region of the address space is reserved for the\nkernel. Application programs are not allowed to read or write the contents of\nthis area or to directly call functions defined in the kernel code. Instead, they\nmust invoke the kernel to perform these operations.")])]),e._v(" "),s("p",[e._v("For virtual memory to work, a sophisticated interaction is required between\nthe hardware and the operating system software, including a hardware translation\nof every address generated by the processor. The basic idea is to store the contents\nof a process’s virtual memory on disk and then use the main memory as a cache\nfor the disk. Chapter 9 explains how this works and why it is so important to the\noperation of modern systems.")]),e._v(" "),s("h2",{attrs:{id:"_1-7-4-files"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-4-files"}},[e._v("#")]),e._v(" 1.7.4 Files")]),e._v(" "),s("p",[e._v("A file is a sequence of bytes, nothing more and nothing less. Every I/O device,\nincluding disks, keyboards, displays, and even networks, is modeled as a file. All\ninput and output in the system is performed by reading and writing files, using a\nsmall set of system calls known as Unix I/O.")]),e._v(" "),s("p",[e._v("This simple and elegant notion of a file is nonetheless very powerful because\nit provides applications with a uniform view of all the varied I/O devices that\nmight be contained in the system. For example, application programmers who\nmanipulate the contents of a disk file are blissfully unaware of the specific disk\ntechnology. Further, the same program will run on different systems that use\ndifferent disk technologies. You will learn about Unix I/O in Chapter 10.")])])}),[],!1,null,null,null);t.default=n.exports}}]);