[From](https://www.bilibili.com/video/av6538245?p=9)
## 1. 操作系统的启动
- DIST：存放 OS
- BIOS：基本 IO 处理系统，接通电源，检查各种外设，加载软件执行
  - 初始已经加载到内存
  - 从特定内存地址开始执行（x86：段寄存器CS:指令寄存器IP = 0xf000:fff0，形成一个具体的内存地址）
    - POST（加电自检），检查外设，寻找显卡和执行 BIOS
    - 将 Bootloader 从硬盘（第一个扇区512字节）加载到内存0x7c00，
    - 跳转到CS:IP = 0000:7c00 控制权交给 Bootloader
- Bootloader：从硬盘加载 OS 到内存
  - 从硬盘起始扇区将操作系统的代码和数据加载到内存
  - 跳转到操作系统起始位置，控制权交给 OS
- 
### 计算机体系结构概述
### 计算机内存和硬盘布局
### 开机顺序

## 2. 中断、异常、系统调用


### 背景

### 中断、异常、系统调用相比较
|   名称   |                   概念                   |      来源      |  处理时间  | 响应           |
| :------: | :--------------------------------------: | :------------: | :--------: | :------------- |
| 系统调用 |    应用程序主动向操作系统发出服务请求    |    应用程序    | 同步或异步 | 等待或持续     |
|   异常   | 非法指令或其他坏的处理状态（如内存出错） | 不良的应用程序 |    同步    | 杀死或重新执行 |
|   中断   | 来自于不同的硬件设备的计时器和网络的中断 |      外设      |    异步    | 持续           |
### 中断和异常处理机制
- 中断是外设的事件
- 异常是内部 CPU 的事件
- 中断和异常迫使 CPU 访问一些被中断和异常服务访问的功能
> 产生中断或异常之后，需要知道这个中断或异常具体是哪个特定服务例程服务，
> 建立一个表（中断表），key是中断或异常号，value是对应的服务例程地址

中断
- 硬件（外设）处理过程
  - 设置中断标记（CPU 初始化）
    1. 将内部、外部事件设置中断标记
    2. CPU根据标记得出中断事件的 ID，并发给操作系统
- 软件（操作系统）处理过程
  - 保存当前处理状态
  - 根据 CPU 给的终端号，找到中断服务程序处理
  - 清除中断标记
  - 恢复之前保持的处理状态

异常：异常编号
- 保存现场
- 异常处理
  - 杀死产生异常的程序
  - 重新执行异常指令
- 恢复现场
### 系统调用的概念
系统调用接口：暴露给应用程序调用
1. Win32 API 用于 Windows
2.  POSIX API 用于 POSIX-based systems（UNIX、LINUX、Mac OS X）
<!-- - Java API 用于 Java 虚拟机 -->
- 系统调用接口根据系统调用相关序号来维护表的索引
- 系统调用接口调用内核态中的系统调用（用户态->内核态），并返回系统调用的状态
  - 用户态：应用程序运行时 CPU 所处的状态，无法直接执行特权指令和 IO 操作
  - 内核态：可以执行特权指令和 IO 操作，完全控制计算机
- 与函数调用区别
  - 函数调用始终处于一个栈
  - 应用程序和内核各自一个堆栈，用户态内核态切换，开销比较大
- 跨域操作系统边界的开销
  - 执行时间开销
    - 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销
    - 建立内核堆栈
    - 验证参数
    - 内核态映射到用户态的地址空间、更新页面映射权限（内核数据拷贝用用户空间）
    - 内核独立地址空间
      - TLB
### 系统调用的实现
### 程序调用和系统调用的不同之处
### 开销
