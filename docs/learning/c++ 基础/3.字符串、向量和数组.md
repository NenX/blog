本章将介绍两种重要的标准库类型 `string` 和 `vector`：
- string：表示可变长的字符序列
- vector：存放某种给定类型对象的可变长序列
- 数组：数组的实现与硬件密切相关，string 和 vector 都是对它的某种抽象，但其灵活性稍有不足
- 迭代器：是 string 和 vector 的配套类型，常被用于访问 string 中的字符或 vector 中的元素
## 命名空间的 using 声明
作用域操作符（::）的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。
```cpp
#include <iostream>
std::string a; // 使用命名空间 std 的中名字 string
```
### using 声明（using declaration）
- 形式：`using namespace::name`
- 无须专门的前缀（namespace::name）也能使用所需的名字
- 每个名字都需要独立的 using 声明：
  ```cpp
  #include <iostream>
  // 一行可以放多条 using 声明语句，但每个名字都必须有自己的 using 声明语句，以分号结束
  using std::cout; using std::endl; 
  using std::string;
  int main()
  {
      string a = "str";
      cout << a << endl;
      return 1;
  }
  ```
### 头文件不应包含 using 声明语句
头文件的内容会被拷贝到所有包含它的文件中去，如果头文件里有某个 using 声明，那么每个使用该头文件的文件都会有这个声明。由于不经意间包含了一些名字，反而可以产生始料未及的名字冲突。
## 标准库类型 string
使用 `string` 类型必须包含 string 头文件，作为标准库的一部分，string 定义在命名空间 std 中：
```cpp
#include <string>
using std::string;
```
### 定义和初始化
| 初始化方式          | 含义                                                    |
| ------------------- | :------------------------------------------------------ |
| string s1           | 默认初始化，s1是一个空字符串                            |
| string s2(s1)       | s2是s1的副本                                            |
| string s2 = s1      | 等价于 s2(s1)                                           |
| string s3("value)   | s3是字面值"value"的副本，除了字面值最后的那个空字符串外 |
| string s3 = "value" | 等价于s3("value")                                       |
| string s4(n,'c')    | 把s4初始化为由连续n个字符'c'组成的串                    |
直接初始化和拷贝初始化：
- 拷贝初始化（copy initialization）：使用等号（=）初始化一个变量
- 直接初始化（direct initialization）：不使用等号初始化
### string 对象上的操作

| 操作             | 含义                                       |
| ---------------- | :----------------------------------------- |
| `os << s`        | 将s写到输出流os当中，返回os                |
| `is >> s`        | 从输入流is读取字符赋给s，返回is            |
| `getline(is, s)` | 从输入流is读取一行赋给s，返回is            |
| `s.empty()`      | s为空返回true，否则返回false               |
| `s.size()`       | 返回s中字符的个数                          |
| `s[n]`           | 返回s中第n个字符的引用                     |
| `s1 + s2`        | 返回s1和s2连接后的结果                     |
| `s1 = s2`        | 用s2的副本替代s1原来的字符                 |
| `s1 == s2`       | 判断s1和s2所含的字符是否完全一样           |
| `s1 != s2`       | 对大小写敏感                               |
| `<, <=, >, >=`   | 利用字符在字典中的顺序进行比较，大小写敏感 |
读写 string 对象
- 执行读写操作时，`string` 对象会自动忽略开头的空白并从第一个真的的字符开始读起，知道遇见下一处空白：
  ```cpp
  string s;
  cin >> s;
  cout << s << std::endl;
  ```
  如果程序输入是“    HELLO WORLD    ”，则输出将是“HELLO”，输出结果没有包含任何空格。

  和内置类型的输入输出一样，string 对象的此类操作也是返回操作符左侧的运算对象作为其结果：
  ```cpp
  string s1, s2;
  cin >> s1 >> s2;
  cout << s1 << s2 << std::endl;
  ```
  如果程序输入是“    HELLO WORLD    ”，则输出将是“HELLOWORLD”。
- 读取未知数量的 string 对象：
  ```cpp
  string s, tmp;
  while (cin >> tmp)
  {
      s += tmp;
  }
  cout << s << std::endl;
  ```

- 如果希望在最终的字符串中保留输入时的空格符，这时应使用 `getline`
  ```cpp
  string s, tmp;
  while (std::getline(std::cin, tmp))
  {
      s += tmp;
      s += "\n";
  }

  std::cout << s << std::endl;
  ```
  `getline` 函数接收一个输入流和一个 `string` 对象，函数从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来），然后把读取的内容存入 `string` 对象中（注意不存换行符）。

string 的 empty 和 size 操作：
- empty：`string` 的一个成员函数，根据 `string` 对象是否为空返回一个对应的布尔值。
- size：返回 string 对象的长度
- string::size_type：`string` 类及其他大多数标准库类型定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性，`string::size_type` 即是其中的一种。`string::size_type` 是一个无符号类型的值而且足够存放下任何 `string` 对象的大小。所有用于存放 `string` 类的 `size` 函数返回值的变量，都应该是 `string::size_type` 类型的。
  ::: tip
  如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。如果一条表达式中已经有了 `size` 函数，就不要再使用 `int`，这样可以避免混用 `int` 和 `unsigned` 可能带来的问题。
  :::
比较 string 对象
- 相等性运算符（== 和 !=）：比较两个 `string` 对象是否长度相等且所包含的字符也全部相同。
- <、<=、>、>=：
  - 如果两个 `string` 对象的长度不通，而且较短 `string` 对象的每个字符都与较长 `string` 对象对应位置上的字符相同，就说较短 `string` 对象小于较长 `string` 对象。
  - 如果 string 对象在某些对应位置上不一致，则 string 对象比较的结果其实就是 string 对象中第一对相异字符比较的结果。
字面值和 string 对象相加

标准库允许将字符字面值与字符串字面值转化成 string 对象，所以在需要 string 对象的地方就可以使用这两种字面量来代替。
```cpp
string s;
s+='a';
s+='b';
std::cout << s << std::endl;
```
::: tip
当把 string 对象和字符字面量及字符串字面量混在一条语句中使用时，必须确保加法运算符（+）的两侧运算对象至少有一个是 string 对象。
```cpp
string s = "";
string s1 = s + "hello" + "world"; // 正确
string s2 = "hello" + "world" + 2; // 错误
```
切记：c++ 语言中的字符串字面量并不是标准库类型 string 的对象，字符串字面量与 string 对象是不同的类型。
:::
### 处理 string 对象中的字符
cctype 头文件中的函数
|   函数   |          含义          |
| :------: | :--------------------: |
| isalnum  |       数字或字母       |
| isalpha  |          数字          |
| isdigit  |          字母          |
| isxdigit |      十六进制数字      |
| isprint  | 可打印：空格、可使形式 |
| isspace  |     空格、空白字符     |
| isgraph  |      非空白可打印      |
| iscntrl  |        控制字符        |
| ispunct  |        标点符号        |
| islower  |        小写字母        |
| isupper  |        大写字母        |
| tolower  |                        |
| toupper  |                        |
::: tip
C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 `name.h`，C++ 则将这些文件命名为 `cname`。 
`cctype` 头文件和 `ctype.h` 头文件的内容是一样的，只不过从命名规范上更复合 C++ 语言的要求。在 `cname` 头文件定义的名字从属于命名空间 `std`，而定义在 `name.h` 中的则不然。
:::
处理每个字符？使用基于范围的 for 语句
```cpp
for (auto i : "abcd")
{
    cout << i << endl;
}
```
使用基于范围的 for 语句改变字符串中的字符
```cpp
std::string s("abcd");
for (auto &i : s)
{
    i = '1';
}
```

## 标准库类型 vector
`vector` 也称为容器（container），表示对象的集合。要想是用 vector，必须包含适当的头文件：
```cpp
#include <vector>
using std::vector;
```
C++ 既有类模板（class template）也有函数模板，其中 vector 是一个类模板。模板不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。

编译器根据模板创建类或函数的过程称为实例化（instantiation），当使用模板时，需要指出编译器应把类或函数实例化为何种类型。
```cpp
vector<char> s;
vector<int> i;
vector<vector<string>> vs;
```
`vector` 能容纳绝大多数类型的对象最为其元素，但是因为引用不是对象，所以不存在包含引用的 `vector`。

在早期 C++ 标准中，如果 `vector` 的元素还是 `vector`，则其定义的形式与现在的 C++11 新标准略有不同。
```cpp
vector<vector<int> > v1; // 在外层 vector 对象的右尖括号和其元素之间添加一个空格，某些编译器仍需要
vector<vector<int>> v2; // 新标准定义形式
```
### 定义和初始化 vector 对象
| 初始化形式                    | 含义                                                        |
| :---------------------------- | :---------------------------------------------------------- |
| `vector<T> v1`                | v1 是一个执行默认初始化的空 vector，其潜在的元素是 T 类型的 |
| `vector<T> v2(v1)`            | v2 中包含了 v1 所有元素的副本                               |
| `vector<T> v2 = v1`           | 等价于 `v2(v1)`                                             |
| `vector<T> v3(n, val)`        | v3 包含了 n 个重复的元素，每个元素的值都是 val              |
| `vector<T> v4(n)`             | v4 包含了 n 个重复的执行了值初始化的对象                    |
| `vector<T> v5{a, b, c...}`    | v5 包含了初始值数量的元素，每个元素被赋予对应的初始值       |
| `vector<T> v5 = {a, b, c...}` | 等价于 v5{a, b, c...}                                       |

- 列表初始化 vector 对象
  
  C++ 语言提供了几种不同的[初始化方式](../c++&#32;基础/变量和基础类型.md#_2-2-变量)，在大多数情况下这些初始化方式可以相互等价地使用。例外情况：
  - 使用[拷贝初始化](#标准库类型-string)时（即使用 = 时），只能提供一个初始值
  - 如果提供一个[类内初始值](变量和基础类型.html#_2-6-1)，则只能使用拷贝初始化或者使用花括号的形式初始化。
  - 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里面进行列表初始化，而不能放在圆括号里。
- 值初始化：如果只提供 vector 对象容纳的元素数量而不提供初始值，此时库会创建一个值初始化的（value-initialized）的元素初值，并把它赋给容器的所有元素。这个初值由 vector 对象中的类型决定：
  - 内置类型：比如 `int`，则元素初始值自动设为 0。
  - 类类型：比如 `string`，则元素由类默认初始化。

  对于这种初始化的方式有两个特殊的限制：
    - 如果 vector 对象中的元素不支持默认初始化，我们就必须提供初始的元素的值。
    - 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化（而不是拷贝初始化）
    ```cpp
    vector<int> vi = 10; // 必须使用直接初始化的形式指定向量大小
    ```
- 列表初始值还是元素数量？
```cpp
vector<int> v1(10); // 10个值都是0的元素
vector<int> v2{10}; // 1个值是10的元素
vector<int> v3(10, 1); // 10个值都是1的元素
vector<int> v4{10, 1}; // 2个值分别是10和1的元素
```
  - 如果用的是圆括号，可以说提供的值是用来构造 `vector` 对象的。
  - 如果用的是花括号：
    - 提供的值满足执行列表初始化时，将花括号的值当作元素初始值的列表来处理
    - 无法执行列表初始化时，将花括号的值用来构造 `vector` 对象
### 向 vector 对象添加元素
直接初始化的方式适应于：
1. 初始值已知且数量少
2. 初始值是另一个 vector 对象的拷贝
3. 所有元素的初始值都一样
`push_back` 把一个值当成 `vector` 对象的尾元素压到（push）`vector` 对象的尾端（back）：
```cpp
 vector<int> v;
 for (int i = 0; i < 10; i++)
 {
     v.push_back(i);
 }
```
::: tip
如果循环体内部包含向 `vector` 对象添加元素的语句，则不能使用范围 `for` 循环。

范围 `for` 循环体内不应改变其所遍历序列的大小。
:::
### 其他 vector 操作
| vector 支持的操作 | 含义 |
| :---------------- | :--- |
| v.empty()         |      |
| v.size()          |      |
| v.push_back(t)    |      |
| v[n]              |      |
| v1 = v2           |      |
| v1 = {a, b, c...} |      |
| v1 == v2          |      |
| v1 != v2          |      |
| <=, <, >, >=      |      |
## 迭代器介绍
标准库容易都支持使用迭代器（iterator），但是其中只有少数几种同时支持下标运算符。

严格来说，`string` 不属于容器类型，但是 `string` 支持很多与容器类型类似的操作：迭代器、下标运算符。
- 类似于指针类型，迭代器也提供了对对象的间接访问。
- 迭代器的对象：容器中的元素或 string 对象中的字符
- 使用迭代器可以访问某个元素，也能从一个元素移动到另一个元素
- 迭代器有有效和无效之分
  - 有效：指向某个元素或指向容器中尾元素的下一位置
  - 无效：其他都属于无效
### 使用迭代器
有迭代器的类型同时拥有返回迭代器的成员：
> `begin`：返回指向第一个元素的迭代器
>
> `end`：返回指向容器尾元素的下一个位置（one past the end）的迭代器（尾迭代器 end iterator）

- 迭代器的运算符

| 使用           | 含义                                    |
| :------------- | :-------------------------------------- |
| *iter          | 返回迭代器 iter 所指元素的引用          |
| iter->mem      | 解引用 iter 并获取该元素名为 mem 的成员 |
| ++iter         | 令 iter 指向容器的下一个元素            |
| --iter         | 令 iter 指向容器的上一个元素            |
| iter1 == iter2 | 是否指向同一个元素                      |
| iter1 != iter2 | 是否指向同一个元素                      |

```cpp
string s("abc");
if (s.begin() != s.end()) // 确保 s 非空
{
    auto it = s.begin();
    *it = toupper(*it);
}
```
- 迭代器类型
```cpp
string::iterator it1; // 读写
vector<int>::iterator it2; // 读写

string::const_iterator it3; // 只读
vector<int>::const_iterator it4; // 只读


string s("");
const string cs("");

auto b1 = cs.begin(); // 只读
auto b2 = s.begin(); // 读写
auto b3 = s.cbegin(); // C++11 新标准，只读
```
> 某些对 vector 的操作会使迭代器失效
> 
> 凡是使用了迭代器的循环体内，都不要向迭代器所属容器增减元素
### 迭代器运算
vector 和 string 迭代器支持的运算
| 使用          | 含义                             |
| :------------ | :------------------------------- |
| iter + n      | 迭代器指向位置向前移动 n 个位置  |
| iter - n      | 迭代器指向位置向后移动 n 个位置  |
| iter += n     |                                  |
| iter -= n     |                                  |
| iter1 - iter2 | 迭代器相减的结果是它们之间的距离 |
| >、>=、<=、<  |                                  |

## 3.5数组
存放类型相同对象的容器，大小确定不变，不能向数据增减元素。

### 3.5.1定义和初始化数组

> 编译时数组的维度应该是已知的，即维度必须是一个大于零[常量表达式](./变量和基础类型.md#constexpr-和常量表达式)。
>
> 定义数组时必须指定数组的类型，不允许用 auto 由初始值的列表推断类型

- 显示初始化数组元素：
  - 列表初始化数组元素，根据初始值计算推断出数组维度
  - 若指明维度：维度必须大于等于初始值元素的数量，剩下的元素被初始化为默认值
  ```cpp
  int a1[] = {1,2}; // 长度为2
  int a2[3] = {1,2}; // {1, 2, 0}
  int a3[3] = {1,2,3,4}; // 错误
  ```
- 字符数组特殊性：使用[字符串字面值](./2.%20变量和基础类型.md#_2-1-3-字面值常量)对数组初始化，字符串末尾的空字符也会被拷贝到数组中去。
- 不允许拷贝和赋值
- 理解复杂的数组声明
  ```cpp
  int arr[1];
  int *ptrs[10]; // 包含10个整型指针
  int (*arrPtr)[1] = &arr; // 指向一个含有1个整型的数组
  int (&arrRef)[1] = arr;// 引用一个含有1个整型的数组
  ```
### 3.5.2访问数组元素
使用数组下标时，通常将其定义为 `size_t` 类型。`size_t` 是一种机器相关的无符号整型，它被设计得足够大以便能表示内存中任意对象的大小。在 cstddef 头文件中定义了 size_t 类型，这个文件是C标准库 stddef 头文件的 C++ 版本。
- 遍历所有元素：范围 for 循环
```cpp
for(auto i: arr){

}
```
### 3.5.3指针和数组
>在很多使用到数组名字的地方，编译器会自动将其替换成一个指向该数组首元素的指针

作为 auto 变量的初始值时，推断出来的类型是指针。而使用 decltype 关键字时得到的类型还是数组：
```cpp
int arr[1];
auto p(arr); // p是一个指向arr首元素的整型指针
decltype(arr) arr2; // arr2 是一个包含一个元素的数组
```
- 指针也是迭代器
vector 和 string 的迭代器支持的运算，数组的指针全都支持。
```cpp
int arr[2] = {1, 1};
auto p = arr;
*(++p) = 3; // 第二个元素设置为3
auto ep = &arr[2]; // 尾后指针
```
- 标准库函数begin和end
尽管可以计算出尾后指针，但是这种用法极易出错，使用 C++11 标准库的两个名为 begin 和 end 的函数更为安全。
```cpp
int arr[2] = {1, 1};
int *b = std::begin(arr),*e = std::end(arr);
int len = e-b;
```
### 3.5.4 C风格字符串
将字符串保存在字符数组中并以空字符结束（null terminated）。

C 语言标准库提供了一组用于操作C风格字符串的函数，它们定义在 cstring 头文件中。
| 用法          |                                    含义                                    |
| :------------ | :------------------------------------------------------------------------: |
| strlen(p)     |                      返回p的长度，空字符串不计算在内                       |
| strcmp(p1,p2) | 如果p1 == p2，返回0；如果p1 > p2，返回一个正值；如果 p1 < p2，返回一个负值 |
| strcat(p1,p2) |                            将p2附加到p1，返回p1                            |
| strcpy(p1,p2) |                            将p2拷贝给p1，返回p1                            |
传入此类函数的指针必须指向空字符串作为结束的字符数组。

### 3.5.5 与旧代码的接口
- 混用 string 和 C 语言风格字符串
  - C 语言风格字符串 -> string
    - 允许使用字符串字面值/以空字符串结束的字符数组来初始化 string，或为string赋值
    - 在 string 对象的加法运算中允许使用C语言风格字符串作为其中一个运算对象
  - string -> C语言风格字符串
    ```cpp
    string s("abcd");
    char *p1 = s; // 错误
    const char *p2 = s.c_str();
    char *p3 = &s[0];
    ```
- 使用数组初始化 vector 对象
```cpp
char cs[] = "abcd";
vector<char> v(std::begin(cs), std::end(cs));
for (auto vb = v.begin(), ve = v.end(); vb != ve; ++vb)
{
    cout << *vb << endl;
}
```
>使用指针和数组很容易出错，现在的 C++ 程序应当尽量使用 vector 和迭代器，避免使用指针和内置数组

>应该尽量使用 string，避免使用 C 风格字符串

## 3.6多维数组

- 多维数组的初始化
  ```cpp
    int a1[2][2] = {0, 2, 3, 4}; // {{0,2},{3,4}}
    int a2[2][2] = {{1}, {2, 2}};// {{1,0},{2,2}}
  ```