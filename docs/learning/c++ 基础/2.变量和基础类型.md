
## 2.1 基本内置类型
包括：
- 算术类型（arithmetic type）：整型（整型数、字符、布尔值）和浮点型（浮点数）。
- 空类型（void type）：不对应具体的值，仅用于一些特殊的场景。例如：当函数不返回任何值时使用空类型作为返回类型。
### 2.1.1 算术类型
### 2.1.2 类型转换
### 2.1.3 字面值常量
- 整型和浮点型字面值
- 字符和字符串字面值
  - 字符字面值
  - 字符串字面值：
    - 本质：常量字符构成的数组，编译器在每个字符串的结尾添加一个空字符（\0），因此字符串字面值的实际长度要比它的内容多1。
    - 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符相隔，则它们实际上是一个整体。
- 转义序列
- 指明字面值的类型
## 2.2 变量
变量提供一个具名的、可供程序修改的存储空间。C++ 每个变量都有其数据类型，数据类型决定了：
- 变量所占内存空间的大小和布局方式
- 该内存空间能存储的值的范围
- 变量能参与的运算
“变量（variable）”和“对象（object）”一般可以互换使用
### 2.2.1 变量定义
- 初始化：对象在创建时获得了一个特定的值，我们说这个对象被初始化（initialize）了。
- 初始值：用于初始化变量的值。初始化（即使使用 = 来初始化）和赋值是两个完全不同的操作
- 列表初始化：Initializes an object from braced-init-list. 使用花括号来初始化变量。

当用于内置类型的变量时：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。
```cpp
double d = 3.1;
int i1 = d;
int i2(d);
int i3{d}; // 报错：从“double”转换到“int”需要收缩转换
int i4 = { d }; // 报错：从“double”转换到“int”需要收缩转换
```
::: tip 初始化不是赋值：
- 初始化：创建变量时赋予其一个初始值
- 赋值：把对象的当前值擦除，再以一个新值来替代
:::
- 默认初始化：如果定义变量时没有指定初始值，则变量被默认初始化（default initialized），此时变量被赋予了“默认值”。
  - 内置类型：
    - 函数体外的内置类型变量被初始化0
    - 函数体内的内置类型变量不被初始化（uninitiated），一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。
  - 每个类各自决定其初始化对象的方式。是否允许不经初始化就定义对象也有类子机决定。绝大多数类支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。
  ```cpp
  std::string s; // 初始化一个内置类型
  ```
### 2.2.2 变量声明和定义的区别
### 2.2.3 标识符
### 2.2.4 名字的作用域

## 2.3 复合类型
### 2.3.1 引用
引用（reference）为对象起了另一个名字，引用类型引用（refer to）另外一种类型。通过将声明符写成 `&d` 的形式来定义引用类型，其中 `d` 是声明的变量名。

一般在初始化时，初始值会被拷贝到新建的对象中。而在定义引用时，程序把引用和初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，无法将引用重新绑定到另外一个对象，因此引用必须初始化。
```cpp
int i = 1;
// d 和 i 绑定到一起，即 d 是 i 的另一个名字
int &d = i;
// 报错：引用必须初始化
int &r;
```
#### 引用即别名
定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。
- 为引用赋值，实际上是将值赋给与之绑定的对象
- 获取引用的值，实际上是获取与之绑定对象的值

引用本身不是一个对象，所以无法定义引用的引用。
#### 引用的定义
允许一条语句中定义多个引用，其中每个标识符都必须以符号 `&` 开头：
```cpp
int i = 1;
int &r1 = i,&r2 = r1;
```
引用只能绑定到对象上，不能绑定与字面量或某个表达式的计算结果绑定在一起。
```cpp
int i;
int &r1 = i + 1; // 报错：非常量引用的初始值必须为左值
int &r2 = 1; // 报错：非常量引用的初始值必须为左值
```
::: tip
为什么 ?
:::
引用的类型必须和与之绑定的对象严格匹配，除了以下两种情况？
1. 定义常量引用时，允许任意表达式作为初始值，只要该表达式的结果能装换成引用的类型即可。
  ```cpp
  int i;
  const int &r1 = i + 1;
  const int &r2 = 1;
  ```
2. 我们可以将基类的指针或引用绑定到派生类对象上
### 2.3.2 指针
指针（pointer）是指向（point to）另外一种类型的复合类型。与引用比较：
- 相同：都实现了对其他对象的间接访问
- 不同：
  - 指针是一个对象，可以对其赋值和拷贝。在指针生命周期内，它可以指向不同的对象。
  - 指针定义时无需初始化，在块级作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。

将声明符写成 `*d` 的形式来定义指针，允许一条语句中定于多个指针，其中每个标识符都必须已 `*` 开头。
```cpp
int *p1, i2; //
```
#### 获取对象的地址
指针存放某个对象的地址，想要获取该地址，需要使用取地址符 `&`。
```cpp
int i = 0;
int *p = &i; // p 存放变量 i 的地址
```
因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了以下两种情况，其他所有的指针的类型都必须和它所指向的对象严格匹配：
1. 允许一个常量指针指向一个非常量对象
2. 我们可以将基类的指针或引用绑定到派生类对象上
#### 指针值
指针的值（即地址）应属于下列四个状态之一：
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针不指向任何对象
4. 无效指针，也就是上述情况之外的其他值

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果是无法预计的，因此程序员必须清楚任意给定的指针是否有效。

经过第 2、3 种指针是有效的，但其使用同样收到限制。显然这类指针并未指向任何具体对象，所以访问这类指针（假定的）对象是不被允许的。如果这样做了，后果也无法预计。
#### 利用指针访问对象
如果指针指向了一个对象，则允许使用解引用符 `*` 来访问该对象。
```cpp
int i = 0, *p = i;
*p = 2;
```
#### 空指针
空指针（null pointer）不指向任何对象，以下列出几个生成空指针的方法：
```cpp
int *p1 = nullptr; // C++11 标准，等价 int *p1 = 0;
int *p2 = 0;
// 需要先 #include "cstdlib"
int *p3 = NULL; // NULL 是 cstdlib 头文件中定义的预处理变量，它的值是 0
```
#### void* 指针
`void*` 指针是一种特殊的指针，可用于存放任意对象的地址，但是对该地址存放的是什么类型的对象并不了解。

void指针能做的事有限：拿它和别的指针比较、作为函数的输入和输出、或者赋值给另外一个void指针，但是我们不能操作 `void*` 指针所指向的对象。
### 2.3.3 理解复合类型的声明
#### 定义多个复合类型变量
```cpp
int i=0, &r = i, *p = &r;
```
#### 指向指针的指针
```cpp
int i=0, *p=&i,**pp = &p; // pp 是指向指针 p 的指针
```
## 2.4 const 限定符
const 对象一旦创建后其值不能再改变，所以 const 对象必须初始化。初始值可以是任意复杂的表达式。
```cpp
int fn()
{
  return 1;
}
const int i = fn();
```
可以将 const 对象拷贝给非 const 对象，一旦拷贝完成，新的对象和原来的对象就没有什么关系了

::: tip 默认情况下，const 对象仅对文件内有效。
当以编译时初始化的方式定义一个 const 对象时，编译器将在编译过程将用到该对象的地方替换成对应值。为此，编译器必须知道 const 变量的初始值，每个用到 const 对象的文件都必须得能访问到它的初始值才行，每个用到 const 变量的文件都必须有对它的定义。默认情况下，const 对象被设定为仅在文件内有效，当多个文件出现了同名的 const 变量时，等同于在不同文件中分别定义了独立的变量。有时，我们希望在一个文件中定义 const 变量，并在多个文件中声明并使用它，这时我们需要在 const 变量定义和声明的地方添加 `extern` 关键字：
```cpp
// c.h
extern const int i;

// c.cpp
int fn()
{
  return 1;
}
extern const int i = fn();
```
:::
### const 的引用
把引用绑定到 const 对象上，我们称之为对常量的引用（reference to const）。对常量的引用不允许被用来改变它所绑定的对象：
```cpp
const int i = 0;
const int &r = i;
int &r2 = r; // 不允许
```
不能将对非常量的引用绑定到 const 对象上，但是允许将对常量的引用绑定到非常量的对象上。
::: tip
我们没法改变引用所绑定的对象，但是引用本身不是一个对象，并不存在常量引用。
:::
#### 初始化和对 const 的引用
初始化常量引用时，允许用任意表达式作为初始值，只要该初始值能转化成引用的类型即可。
```cpp
double d = 1.33;
// 中间省略的步骤
// const int tmp = d;
// const int &r = tmp;
const int &r = d;
```
### 指针和 const
#### 指向常量的指针
指向常量的指针（pointer to const）不能用于改变所指向对象的值。想要存放常量对象的地址，只能使用指向常量的指针：
```cpp
const int i = 2;
const double d= 2.0;
int *p1 = &i; // 错误
const int *p2 = &d; // 错误
const int *p3 = &i;
```
指向常量的指针也可以指向非常量对象，只不过不能通过其改变所指向对象的值。
#### const 指针
指针本身也是对象，允许将指针定义为常量。常量指针（const pointer）定义是必须初始化，一旦初始化完成，就不能改变该指针所存放的地址。
常量指针并不意味不能通过它改变所指向对象的值.
```cpp
int i = 0;
int o = 1;
int *const p = &i;
*p = 222;
p = &o; // 错误
```
### 顶层 const
指针本身是不是常量和指针指向的是不是一个常量对象，是两个相互独立的问题。顶层 const（top-level const）表示指针本身是个常量，底层 const（low-level const）指指针指向的是一个常量对象。

当执行对象拷贝操作时，顶层 const 和底层 const 区别明显：
1. 拷贝顶层 const时：不受影响
2. 拷贝底层 const时，拷入和拷出的对象必须具有相同的 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转化为常量：
```cpp
    int i = 0;
    const int ci = 0;
    int *p1 = &i;
    const int *p2 = p1;
    int *p3 = p2; // 错误
    int &r = ci;  // 错误
    int *p = &ci; // 错误
```
### constexpr 和常量表达式
常量表达式（const expression）是指值不会改变且在编译过程就能得到计算结果的表达式。显然，字面量属于常量表达式，用字面量初始化的 const 对象也属于常量表达式。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定：
```cpp
int i = 0;  //数据类型不是const int
const int c1 = 2; // 常量表达式
const int c2 = c1 + 1; // 常量表达式
const int c3 = fn() // 取决于fn
```
C++新标准规定，允许将变量声明为 constexpr 类型以便编译器来验证变量的值是否是一个常量表达式

```cpp
constexpr int i = 0;
```

::: tip
修饰 Object：
- const 未区分出编译期常量和运行时常量
- constexpr 限定了编译期常量

修饰函数：
constexpr 修饰的函数返回值不一定时编译期常量。#It is not a bug, it is a feature.#
```cpp
// 返回值是否是常量表达式取决于 i
constexpr int fn(int i)
{
    return i;
}
int i = 0;
const int i2 = fn(0); // 常量表达式
const int i3 = fn(i); // 非常量表达式
```
constexpr修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。但是，传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和普通函数一样了。不过，我们不必因此而写两个版本，所以如果函数体适用于constexpr函数的条件，可以尽量加上constexpr。
:::
#### 字面值类型
常量表达式的值需要在编译时就得以计算，因此对声明 constexpr 时用到的类型必须有所显示。因为这些类型一般比较简单，值也显而易见、容易得到，因此就把它们称之为字面值类型（literal type）。
- 算术类型、引用和指针属于字面值类型
- 自定义类、string类型和IO库等不属于字面值类型，也就不能定义为constexpr
  
尽管指针和引用都能被定义成 constexpr，但它们的初始值受到严格的限制。一个 constexpr 指针的初始值必须是 nullptr 或 0，或是存储于某个固定地址的对象。

函数内部定义的变量并非存放在固定地址中，因此 constexpr 指针不能指向这类变量。相反的，定义在函数外部的变量其地址固定不变，能用来初始化 constexpr 指针。函数内可以定义一类有效访问超出函数本身的变量，这类变量和定义在函数外部的变量一样拥有固定地址，因此 constexpr 引用能绑定到这类变量上，constexpr 指针也能指向这样的变量。
```cpp
int i0;
int main()
{

    int i = 0;
    constexpr int &r0 = i0;
    constexpr int *r0 = &i0;
    constexpr int &r = i;  // 报错
    constexpr int *r = &i; // 报错
    return 0;
}
```
#### 指针和 constexpr
constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针指向的对象无关。
```cpp
int i = 0;
const int *p1 = &i; // 指向常量的指针
constexpr int *p2 = &i; // 常量指针，顶层const
```
constexpr 指向既能指向常量也能指向非常量：
```cpp
int i;
const int ci = 0;
int main()
{
    
    constexpr const int &r0 = ci;
    constexpr int *p0 = &i;
    constexpr const int *p1 = nullptr;
    return 0;
}
```
## 2.5 处理类型

### 类型别名
类型别名（type alias）是某种类型的同义词。有两种定义类型别名的方法：
1. 传统方法是使用关键字 typedef：
   ```cpp
    typedef const int size, *size_pointer;
    size s = 123;
    size_pointer sp = &s;
   ```
2. 新标准可以使用类型声明（type declaration）来定义类型别名：
   ```cpp
   using size = int;
   ```
#### 指针、常量和类型别名
```cpp
    typedef const int size, *size_pointer;
    const size_pointer sp = nullptr; // sp 是一个指针 int 类型的常量指针
    const size_pointer *spp = nullptr; // spp 是一个指针，它的对象是指向 int 类型的常量指针
    return 1;
```
### auto 类型说明符
auto 让编辑器通过初始值来推断变量的类型，显然 auto 定义的变量必须有初始值。

使用 auto 也能在一条语句中定义多个变量，该语句中所有变量的初始基本类型必须相同：
```cpp
    auto i = 0, *ip = &i;
    auto i = 0, d = 0.1; // 出错
```
### 复合类型、常量和 auto
编译器推断出来的 auto 类型有时候和初始值类型并不完全一样，编译器会适当修改结果类型使其更复合初始化规则。
- 引用类型：当引用被用作初始值时，真正参与初始化的是引用对象的值，此时编译器将引用对象的类型作为 auto 类型。
- const：
  - 一般会忽略掉顶层 const，底层 const 则会保留下来。
    ```cpp
    int i = 0, &r = i;
    const int ci = 0, &cr = ci;
    auto a = r;  // a 的类型是 int
    auto b = ci; // b 的类型是 int（顶层const被忽略）
    auto c = cr; // b 的类型是 int（顶层const被忽略）
    auto d = &i; // int *d
    auto e = &ci; // const int *e
    ```
  - 如果希望推断出的 auto 类型是一个顶层 const，需要明确指出：
    ```cpp
    const auto f = 0;
    ```
  - 设置一个类型为 auto 的引用时，初始值中的顶层 const 属性仍然保留。
    ```cpp
    const int ci = 0;
    auto &g = ci; // const int &g
    auto &h = 0; // 报错，非常量引用的初始值必须是左值
    const auto &j = 0; // const int &j
    ```
要在一条语句中定义多个变量，符号 `&` 和 `*` 只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须同一种类型：
```cpp
const int ci = 0;
int i = 0;
auto &k = ci, &l = i; // 报错：k 初始值是 const int，而 l 初始值是 int
auto &m = ci, *n = &ci; // 初始值都是 const int
auto &o = i, *p = &ci; // 报错，o 初始值是 int，而 p 初始值是 const int
```
### decltype 类型指示符
为了从表达式的类型推断出要定义变量的类型，而不想用该表达式初始化变量，C++ 标准引入第二种类型说明符 `decltype` ，它的作用是选择并返回操作数的类型。在此过程，编译器分析并得到表达式的值，却不实际计算表达式的值。

处理顶层 `const` 和 引用：与 `const` 不同，如果 `decltype` 使用的表达式是一个变量，则 `decltype` 返回该变量的类型（包括顶层const和引用）。
```cpp
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x 的类型是 const int
decltype(cj) y = ci; // y 的类型是 const int&，绑定到 ci
decltype(cj) z; // 错误：引用 z 必须初始化
```
#### decltype 和引用：
如果 `decltype` 是用的表达式不是一个变量，则 `decltype` 返回该表达式结果对应的类型。
```cpp
int i = 0, *p = &i, &r = i;
decltype(r + 1) b; // int
decltype(&i) c; // int *c
decltype(*p) const d = 0; // int &d，报错：引用类型必须初始化
```
`decltype` 和 `auto` 的另一重要区别是，`decltype` 的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于 `decltype` 所用的表达式来说，如果变量名加上一对括号，则得到的类型与不加括号时有所不同。如果 `decltype` 使用的是一个不加括号的变量，则得到的结果就是变量的类型。

如果给变量加上一层或多层括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达，所以这样的 `decltype` 就会得到引用类型：
```cpp
int i = 0, *p = &i, &r = i;
decltype(p) d1; // *int d1
decltype((p)) d2; // int *&d2，报错：引用需要初始化
```
::: tip
切记：`decltype((variable))` 的类型永远是引用，而 `decltype(variable)` 的结果只有当 variable 本身是引用时才是引用。
:::
## 2.6 自定义数据类型
### 2.6.1 

- struct 结构体：以关键字 `struct` 开始，紧跟类名和类体。类体由花括号包围形成一个新的作用域。类内部的名字必须唯一，但可以与类外部定义的名字重复。
  ::: tip 类体右侧的表示结束的花括号后必须写一个分号
  这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。
  :::
- 类数据成员：C++11 新标准规定，可以为类数据成员提供一个类内初始值（in-class initializer）。创建对象时，类内初始值用于初始化数据成员。没有初始值的成员将被[默认初始化](#_2-2-变量)
  ::: tip
  类内初始值的限制：或者放花括号，或者放等号右边，记住不能使用圆括号。
  :::